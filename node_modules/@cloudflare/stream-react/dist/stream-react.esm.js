import React, { useState, useEffect, useMemo, useRef } from 'react';

var sdkScriptLocation = "https://embed.videodelivery.net/embed/sdk.latest.js"; // This needs to be wrapped as such for two reasons:
// - Stream is a function, and useState invokes functions immediately and uses the return value.
// - We need to check typeof on window to ensure safety for server side rendering.

var safelyAccessStreamSDK = function safelyAccessStreamSDK() {
  if (typeof window === "undefined") return undefined;
  return window.Stream;
};
function useStreamSDK() {
  var _useState = useState(safelyAccessStreamSDK),
      streamSdk = _useState[0],
      setStreamSdk = _useState[1];

  useEffect(function () {
    if (!streamSdk) {
      var existingScript = document.querySelector("script[src='" + sdkScriptLocation + "']");
      var script = existingScript !== null && existingScript !== void 0 ? existingScript : document.createElement("script");
      script.addEventListener("load", function () {
        setStreamSdk(safelyAccessStreamSDK);
      });

      if (!existingScript) {
        script.src = sdkScriptLocation;
        document.head.appendChild(script);
      }
    }
  }, [streamSdk]);
  return streamSdk;
}

function useIframeSrc(src, _ref) {
  var muted = _ref.muted,
      preload = _ref.preload,
      loop = _ref.loop,
      autoplay = _ref.autoplay,
      controls = _ref.controls,
      poster = _ref.poster,
      primaryColor = _ref.primaryColor,
      adUrl = _ref.adUrl,
      startTime = _ref.startTime,
      defaultTextTrack = _ref.defaultTextTrack;
  var paramString = [poster && "poster=" + encodeURIComponent(poster), adUrl && "ad-url=" + encodeURIComponent(adUrl), defaultTextTrack && "defaultTextTrack=" + encodeURIComponent(defaultTextTrack), primaryColor && "primaryColor=" + encodeURIComponent(primaryColor), startTime && "startTime=" + startTime, muted && "muted=true", preload && "preload=" + preload, loop && "loop=true", autoplay && "autoplay=true", !controls && "controls=false"].filter(Boolean).join("&");
  var iframeSrc = useMemo(function () {
    return "https://iframe.videodelivery.net/" + src + "?" + paramString;
  }, // we intentionally do NOT include paramString here because we want
  // to avoid changing the URL when these options change. Changes to
  // these options will instead be handled separately via the SDK.
  []);
  return iframeSrc;
}

function validSrcUrl(str) {
  try {
    var url = new URL(str);
    return url.hostname.endsWith("videodelivery.net");
  } catch (_unused) {
    return false;
  }
}

/**
 * Hook for syncing properties to the SDK api when they change
 */

function useProperty(name, ref, value) {
  useEffect(function () {
    if (!ref.current) return;
    var el = ref.current;
    el[name] = value;
  }, [name, value, ref]);
}
/**
 * Hook for binding event listeners to the player.
 */


function useEvent(event, ref, callback) {
  if (callback === void 0) {
    callback = noop;
  }

  useEffect(function () {
    if (!ref.current) return;
    var el = ref.current;
    el.addEventListener(event, callback); // clean up

    return function () {
      return el.removeEventListener(event, callback);
    };
  }, [callback, event, ref]);
} // Declaring a single noop function that will retain object
// identity across renders and prevent unnecessary rebinding
// when no callback is provided


var noop = function noop() {};

var Stream = function Stream(props) {
  var streamSdk = useStreamSDK();
  return streamSdk ? React.createElement(StreamEmbed, Object.assign({}, props)) : null;
};
var responsiveIframeStyles = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  height: "100%",
  width: "100%"
};

var Container = function Container(_ref) {
  var children = _ref.children,
      responsive = _ref.responsive,
      className = _ref.className,
      videoDimensions = _ref.videoDimensions;
  var videoHeight = videoDimensions.videoHeight,
      videoWidth = videoDimensions.videoWidth;
  var responsiveStyles = useMemo(function () {
    return {
      position: "relative",
      paddingTop: videoWidth > 0 ? videoHeight / videoWidth * 100 + "%" : undefined
    };
  }, [videoWidth, videoHeight]);
  return React.createElement("div", {
    className: className,
    style: responsive ? responsiveStyles : undefined
  }, children);
};

var StreamEmbed = function StreamEmbed(_ref2) {
  var src = _ref2.src,
      adUrl = _ref2.adUrl,
      _ref2$controls = _ref2.controls,
      controls = _ref2$controls === void 0 ? false : _ref2$controls,
      _ref2$muted = _ref2.muted,
      muted = _ref2$muted === void 0 ? false : _ref2$muted,
      _ref2$autoplay = _ref2.autoplay,
      autoplay = _ref2$autoplay === void 0 ? false : _ref2$autoplay,
      _ref2$loop = _ref2.loop,
      loop = _ref2$loop === void 0 ? false : _ref2$loop,
      _ref2$preload = _ref2.preload,
      preload = _ref2$preload === void 0 ? "metadata" : _ref2$preload,
      primaryColor = _ref2.primaryColor,
      defaultTextTrack = _ref2.defaultTextTrack,
      height = _ref2.height,
      width = _ref2.width,
      poster = _ref2.poster,
      _ref2$currentTime = _ref2.currentTime,
      currentTime = _ref2$currentTime === void 0 ? 0 : _ref2$currentTime,
      _ref2$volume = _ref2.volume,
      volume = _ref2$volume === void 0 ? 1 : _ref2$volume,
      startTime = _ref2.startTime,
      streamRef = _ref2.streamRef,
      _ref2$responsive = _ref2.responsive,
      responsive = _ref2$responsive === void 0 ? true : _ref2$responsive,
      className = _ref2.className,
      title = _ref2.title,
      onAbort = _ref2.onAbort,
      onCanPlay = _ref2.onCanPlay,
      onCanPlayThrough = _ref2.onCanPlayThrough,
      onDurationChange = _ref2.onDurationChange,
      onEnded = _ref2.onEnded,
      onError = _ref2.onError,
      onLoadedData = _ref2.onLoadedData,
      onLoadedMetaData = _ref2.onLoadedMetaData,
      onLoadStart = _ref2.onLoadStart,
      onPause = _ref2.onPause,
      onPlay = _ref2.onPlay,
      onPlaying = _ref2.onPlaying,
      onProgress = _ref2.onProgress,
      onRateChange = _ref2.onRateChange,
      onResize = _ref2.onResize,
      onSeeked = _ref2.onSeeked,
      onSeeking = _ref2.onSeeking,
      onStalled = _ref2.onStalled,
      onSuspend = _ref2.onSuspend,
      onTimeUpdate = _ref2.onTimeUpdate,
      onVolumeChange = _ref2.onVolumeChange,
      onWaiting = _ref2.onWaiting,
      onStreamAdStart = _ref2.onStreamAdStart,
      onStreamAdEnd = _ref2.onStreamAdEnd,
      onStreamAdTimeout = _ref2.onStreamAdTimeout;
  var internalRef = useRef();
  var ref = streamRef !== null && streamRef !== void 0 ? streamRef : internalRef;

  var _useState = useState({
    videoHeight: 0,
    videoWidth: 0
  }),
      videoDimensions = _useState[0],
      setVideoDimensions = _useState[1];

  var iframeRef = useRef(null);
  var computedSrc = useIframeSrc(src, {
    muted: muted,
    preload: preload,
    loop: loop,
    autoplay: autoplay,
    controls: controls,
    poster: poster,
    primaryColor: primaryColor,
    adUrl: adUrl,
    defaultTextTrack: defaultTextTrack,
    startTime: startTime
  }); // While it's easier for most consumers to simply provide the video id
  // or signed URL and have us compute the iframe's src for them, some
  // consumers may need to manually specify the iframe's src.

  var iframeSrc = validSrcUrl(src) ? src : computedSrc;
  useProperty("muted", ref, muted);
  useProperty("controls", ref, controls);
  useProperty("src", ref, src);
  useProperty("autoplay", ref, autoplay);
  useProperty("currentTime", ref, currentTime);
  useProperty("loop", ref, loop);
  useProperty("preload", ref, preload);
  useProperty("primaryColor", ref, primaryColor);
  useProperty("volume", ref, volume); // instantiate API after properties are bound because we want undefined
  // values to be set before defining the properties

  useEffect(function () {
    var Stream = safelyAccessStreamSDK();

    if (iframeRef.current && Stream) {
      var api = Stream(iframeRef.current);
      ref.current = api;
      var videoHeight = api.videoHeight,
          videoWidth = api.videoWidth;
      if (videoHeight && videoWidth) setVideoDimensions({
        videoHeight: videoHeight,
        videoWidth: videoWidth
      });
    }
  }, []); // bind events

  useEvent("abort", ref, onAbort);
  useEvent("canplay", ref, onCanPlay);
  useEvent("canplaythrough", ref, onCanPlayThrough);
  useEvent("durationchange", ref, onDurationChange);
  useEvent("ended", ref, onEnded);
  useEvent("error", ref, onError);
  useEvent("loadeddata", ref, onLoadedData);
  useEvent("loadedmetadata", ref, onLoadedMetaData);
  useEvent("loadstart", ref, onLoadStart);
  useEvent("pause", ref, onPause);
  useEvent("play", ref, onPlay);
  useEvent("playing", ref, onPlaying);
  useEvent("progress", ref, onProgress);
  useEvent("ratechange", ref, onRateChange);
  useEvent("seeked", ref, onSeeked);
  useEvent("seeking", ref, onSeeking);
  useEvent("stalled", ref, onStalled);
  useEvent("suspend", ref, onSuspend);
  useEvent("timeupdate", ref, onTimeUpdate);
  useEvent("volumechange", ref, onVolumeChange);
  useEvent("waiting", ref, onWaiting);
  useEvent("stream-adstart", ref, onStreamAdStart);
  useEvent("stream-adend", ref, onStreamAdEnd);
  useEvent("stream-adtimeout", ref, onStreamAdTimeout);
  useEvent("resize", ref, function (e) {
    if (ref.current) {
      var _ref$current = ref.current,
          videoHeight = _ref$current.videoHeight,
          videoWidth = _ref$current.videoWidth;
      setVideoDimensions({
        videoHeight: videoHeight,
        videoWidth: videoWidth
      });
      onResize && onResize(e);
    }
  });
  return React.createElement(Container, {
    className: className,
    responsive: responsive,
    videoDimensions: videoDimensions
  }, React.createElement("iframe", {
    ref: iframeRef,
    src: iframeSrc,
    title: title,
    style: responsive ? responsiveIframeStyles : undefined,
    frameBorder: 0,
    height: height,
    width: width,
    allow: "accelerometer; gyroscope; autoplay; encrypted-media; picture-in-picture;",
    allowFullScreen: true
  }));
};

export { Stream, useStreamSDK };
//# sourceMappingURL=stream-react.esm.js.map
