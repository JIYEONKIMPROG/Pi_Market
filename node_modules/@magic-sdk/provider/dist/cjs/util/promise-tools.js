"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("./events");
var promiEventBrand = Symbol('isPromiEvent');
/**
 * Returns `true` if the given `value` is a `PromiEvent`.
 */
function isPromiEvent(value) {
    return !!value[promiEventBrand];
}
exports.isPromiEvent = isPromiEvent;
/**
 * Create a native JavaScript `Promise` overloaded with strongly-typed methods
 * from `EventEmitter`.
 */
function createPromiEvent(executor) {
    var promise = createPromise(executor);
    var _a = events_1.createTypedEmitter(), createBoundEmitterMethod = _a.createBoundEmitterMethod, createChainingEmitterMethod = _a.createChainingEmitterMethod;
    // We save the original `Promise` methods to the following symbols so we can
    // access them internally.
    var thenSymbol = Symbol('Promise.then');
    var catchSymbol = Symbol('Promise.catch');
    var finallySymbol = Symbol('Promise.finally');
    /**
     * Ensures the next object in the `PromiEvent` chain is overloaded with
     * `EventEmitter` methods.
     */
    var createChainingPromiseMethod = function (method, source) { return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var nextPromise = source[method].apply(source, args);
        return promiEvent(nextPromise);
    }; };
    /**
     * Builds a `PromiEvent` by assigning `EventEmitter` methods to a native
     * `Promise` object.
     */
    var promiEvent = function (source) {
        var _a;
        return Object.assign(source, (_a = {},
            _a[promiEventBrand] = true,
            _a[thenSymbol] = source[thenSymbol] || source.then,
            _a[catchSymbol] = source[catchSymbol] || source.catch,
            _a[finallySymbol] = source[finallySymbol] || source.finally,
            _a.then = createChainingPromiseMethod(thenSymbol, source),
            _a.catch = createChainingPromiseMethod(catchSymbol, source),
            _a.finally = createChainingPromiseMethod(finallySymbol, source),
            _a.on = createChainingEmitterMethod('on', source),
            _a.once = createChainingEmitterMethod('once', source),
            _a.addListener = createChainingEmitterMethod('addListener', source),
            _a.off = createChainingEmitterMethod('off', source),
            _a.removeListener = createChainingEmitterMethod('removeListener', source),
            _a.removeAllListeners = createChainingEmitterMethod('removeAllListeners', source),
            _a.emit = createBoundEmitterMethod('emit'),
            _a.eventNames = createBoundEmitterMethod('eventNames'),
            _a.listeners = createBoundEmitterMethod('listeners'),
            _a.listenerCount = createBoundEmitterMethod('listenerCount'),
            _a));
    };
    var result = promiEvent(promise.then(function (resolved) {
        // Emit default completion events and resolve result.
        result.emit('done', resolved);
        result.emit('settled');
        return resolved;
    }, function (err) {
        // Emit default error events and re-throw.
        result.emit('error', err);
        result.emit('settled');
        throw err;
    }));
    return result;
}
exports.createPromiEvent = createPromiEvent;
/**
 * Creates a `Promise` with an **async executor** that automatically catches
 * errors occurring within the executor. Nesting promises in this way is usually
 * deemed an _anti-pattern_, but it's useful and clean when promisifying the
 * event-based code that's inherent to JSON RPC.
 *
 * So, here we solve the issue of nested promises by ensuring that no errors
 * mistakenly go unhandled!
 */
function createPromise(executor) {
    return new Promise(function (resolve, reject) {
        var result = executor(resolve, reject);
        Promise.resolve(result).catch(reject);
    });
}
exports.createPromise = createPromise;
//# sourceMappingURL=promise-tools.js.map