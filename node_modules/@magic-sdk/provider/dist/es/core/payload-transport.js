import { __awaiter, __generator } from "tslib";
import { MagicIncomingWindowMessage, } from '@magic-sdk/types';
import { JsonRpcResponse } from './json-rpc';
import { createPromise } from '../util/promise-tools';
import { getItem, setItem } from '../util/storage';
import { createJwt } from '../util/web-crypto';
import { SDKEnvironment } from './sdk-environment';
/**
 * Get the originating payload from a batch request using the specified `id`.
 */
function getRequestPayloadFromBatch(requestPayload, id) {
    return id && Array.isArray(requestPayload)
        ? requestPayload.find(function (p) { return p.id === id; })
        : requestPayload;
}
/**
 * Ensures the incoming response follows the expected schema and parses for a
 * JSON RPC payload ID.
 */
function standardizeResponse(requestPayload, event) {
    var _a;
    var id = (_a = event.data.response) === null || _a === void 0 ? void 0 : _a.id;
    var requestPayloadResolved = getRequestPayloadFromBatch(requestPayload, id);
    if (id && requestPayloadResolved) {
        // Build a standardized response object
        var response = new JsonRpcResponse(requestPayloadResolved)
            .applyResult(event.data.response.result)
            .applyError(event.data.response.error);
        return { id: id, response: response };
    }
    return {};
}
function createMagicRequest(msgType, payload) {
    return __awaiter(this, void 0, void 0, function () {
        var rt, jwt, e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, getItem('rt')];
                case 1:
                    rt = _a.sent();
                    if (!(SDKEnvironment.platform === 'web')) return [3 /*break*/, 5];
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, createJwt()];
                case 3:
                    jwt = _a.sent();
                    return [3 /*break*/, 5];
                case 4:
                    e_1 = _a.sent();
                    console.error('webcrypto error', e_1);
                    return [3 /*break*/, 5];
                case 5:
                    if (!jwt) {
                        return [2 /*return*/, { msgType: msgType, payload: payload }];
                    }
                    if (!rt) {
                        return [2 /*return*/, { msgType: msgType, payload: payload, jwt: jwt }];
                    }
                    return [2 /*return*/, { msgType: msgType, payload: payload, jwt: jwt, rt: rt }];
            }
        });
    });
}
function persistMagicEventRefreshToken(event) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!event.data.rt) {
                        return [2 /*return*/];
                    }
                    return [4 /*yield*/, setItem('rt', event.data.rt)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
var PayloadTransport = /** @class */ (function () {
    /**
     * Create an instance of `PayloadTransport`
     *
     * @param endpoint - The URL for the relevant iframe context.
     * @param parameters - The unique, encoded query parameters for the
     * relevant iframe context.
     */
    function PayloadTransport(endpoint, parameters) {
        this.endpoint = endpoint;
        this.parameters = parameters;
        this.messageHandlers = new Set();
        this.init();
    }
    PayloadTransport.prototype.post = function (overlay, msgType, payload) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, createPromise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                        var batchData, batchIds, msg, acknowledgeResponse, removeResponseListener;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, overlay.ready];
                                case 1:
                                    _a.sent();
                                    batchData = [];
                                    batchIds = Array.isArray(payload) ? payload.map(function (p) { return p.id; }) : [];
                                    return [4 /*yield*/, createMagicRequest(msgType + "-" + this.parameters, payload)];
                                case 2:
                                    msg = _a.sent();
                                    return [4 /*yield*/, overlay.postMessage(msg)];
                                case 3:
                                    _a.sent();
                                    acknowledgeResponse = function (removeEventListener) { return function (event) {
                                        var _a = standardizeResponse(payload, event), id = _a.id, response = _a.response;
                                        persistMagicEventRefreshToken(event);
                                        if (id && response && Array.isArray(payload) && batchIds.includes(id)) {
                                            batchData.push(response);
                                            // For batch requests, we wait for all responses before resolving.
                                            if (batchData.length === payload.length) {
                                                removeEventListener();
                                                resolve(batchData);
                                            }
                                        }
                                        else if (id && response && !Array.isArray(payload) && id === payload.id) {
                                            removeEventListener();
                                            resolve(response);
                                        }
                                    }; };
                                    removeResponseListener = this.on(MagicIncomingWindowMessage.MAGIC_HANDLE_RESPONSE, acknowledgeResponse(function () { return removeResponseListener(); }));
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Listen for events received with the given `msgType`.
     *
     * @param msgType - The `msgType` encoded with the event data.
     * @param handler - A handler function to execute on each event received.
     * @return A `void` function to remove the attached event.
     */
    PayloadTransport.prototype.on = function (msgType, handler) {
        var _this = this;
        var boundHandler = handler.bind(window);
        // We cannot effectively cover this function because it never gets reference
        // by value. The functionality of this callback is tested within
        // `initMessageListener`.
        /* istanbul ignore next */
        var listener = function (event) {
            if (event.data.msgType === msgType + "-" + _this.parameters)
                boundHandler(event);
        };
        this.messageHandlers.add(listener);
        return function () { return _this.messageHandlers.delete(listener); };
    };
    return PayloadTransport;
}());
export { PayloadTransport };
//# sourceMappingURL=payload-transport.js.map