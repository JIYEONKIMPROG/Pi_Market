{"version":3,"file":"crypto-ts.js","sources":["../../src/enc/Hex.ts","../../src/lib/WordArray.ts","../../src/enc/Latin1.ts","../../src/enc/Utf8.ts","../../src/lib/BufferedBlockAlgorithm.ts","../../src/lib/Base.ts","../../src/lib/CipherParams.ts","../../src/enc/Base64.ts","../../src/format/OpenSSL.ts","../../src/lib/SerializableCipher.ts","../../src/lib/Hasher.ts","../../src/algo/MD5.ts","../../src/algo/EvpKDF.ts","../../src/kdf/OpenSSLKdf.ts","../../src/lib/PasswordBasedCipher.ts","../../src/lib/Cipher.ts","../../src/mode/BlockCipherModeAlgorithm.ts","../../src/mode/BlockCipherMode.ts","../../src/mode/CBCEncryptor.ts","../../src/mode/CBCDecryptor.ts","../../src/mode/CBC.ts","../../src/pad/PKCS7.ts","../../src/lib/BlockCipher.ts","../../src/algo/AES.ts","../../src/algo/SHA256.ts","../../src/pad/NoPadding.ts","../../src/mode/ECBEncryptor.ts","../../src/mode/ECBDecryptor.ts","../../src/mode/ECB.ts","../../src/crypto-ts.ts"],"sourcesContent":["import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\n\nexport class Hex {\n    /**\n     * Converts a word array to a hex string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The hex string.\n     *\n     * @example\n     *\n     *     let hexString = Hex.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        // Convert\n        const hexChars: Array<string> = [];\n        for (let i = 0; i < wordArray.sigBytes; i++) {\n            const bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            hexChars.push((bite >>> 4).toString(16));\n            hexChars.push((bite & 0x0f).toString(16));\n        }\n\n        return hexChars.join('');\n    }\n\n    /**\n     * Converts a hex string to a word array.\n     *\n     * @param hexStr The hex string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Hex.parse(hexString);\n     */\n    public static parse(hexStr: string): WordArray {\n        // Shortcut\n        const hexStrLength = hexStr.length;\n\n        // Convert\n        const words: Array<number> = [];\n        for (let i = 0; i < hexStrLength; i += 2) {\n            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n        }\n\n        return new WordArray(words, hexStrLength / 2);\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Hex;","import { Encoding } from '../enc/Encoding';\nimport { Hex } from '../enc/Hex';\n\nexport class WordArray {\n    words: Array<number>;\n\n    sigBytes: number;\n\n    /**\n     * Creates a word array filled with random bytes.\n     *\n     * @param nBytes The number of random bytes to generate.\n     *\n     * @return The random word array.\n     *\n     * @example\n     *\n     *     let wordArray = WordArray.random(16);\n     */\n    public static random(nBytes: number) {\n        const words = [];\n\n        const r = (function(m_w: number) {\n            let m_z = 0x3ade68b1;\n\n            const mask = 0xffffffff;\n\n            return function() {\n                m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n                m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n                let result = ((m_z << 0x10) + m_w) & mask;\n                result /= 0x100000000;\n                result += 0.5;\n                return result * (Math.random() > .5 ? 1 : -1);\n            };\n        });\n\n        for(let i = 0, rcache; i < nBytes; i += 4) {\n            const _r = r((rcache || Math.random()) * 0x100000000);\n\n            rcache = _r() * 0x3ade67b7;\n            words.push((_r() * 0x100000000) | 0);\n        }\n\n        return new WordArray(words, nBytes);\n    }\n\n    /**\n     * Initializes a newly created word array.\n     *\n     * @param words (Optional) An array of 32-bit words.\n     * @param sigBytes (Optional) The number of significant bytes in the words.\n     *\n     * @example\n     *\n     *     let wordArray = new WordArray();\n     *     let wordArray = new WordArray([0x00010203, 0x04050607]);\n     *     let wordArray = new WordArray([0x00010203, 0x04050607], 6);\n     */\n    constructor(words?: Array<number>, sigBytes?: number) {\n        this.words = words || [];\n\n        if(sigBytes !== undefined) {\n            this.sigBytes = sigBytes;\n        } else {\n            this.sigBytes = this.words.length * 4;\n        }\n    }\n\n    /**\n     * Converts this word array to a string.\n     *\n     * @param encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n     *\n     * @return The stringified word array.\n     *\n     * @example\n     *\n     *     let string = wordArray + '';\n     *     let string = wordArray.toString();\n     *     let string = wordArray.toString(CryptoJS.enc.Utf8);\n     */\n    toString(encoder?: Encoding): string {\n        return (encoder || Hex).stringify(this);\n    }\n\n    /**\n     * Concatenates a word array to this word array.\n     *\n     * @param wordArray The word array to append.\n     *\n     * @return This word array.\n     *\n     * @example\n     *\n     *     wordArray1.concat(wordArray2);\n     */\n    concat(wordArray: WordArray): WordArray {\n        // Clamp excess bits\n        this.clamp();\n\n        // Concat\n        if(this.sigBytes % 4) {\n            // Copy one byte at a time\n            for(let i = 0; i < wordArray.sigBytes; i++) {\n                const thatByte = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                this.words[(this.sigBytes + i) >>> 2] |= thatByte << (24 - ((this.sigBytes + i) % 4) * 8);\n            }\n        } else {\n            // Copy one word at a time\n            for (let i = 0; i < wordArray.sigBytes; i += 4) {\n                this.words[(this.sigBytes + i) >>> 2] = wordArray.words[i >>> 2];\n            }\n        }\n        this.sigBytes += wordArray.sigBytes;\n\n        // Chainable\n        return this;\n    }\n\n    /**\n     * Removes insignificant bits.\n     *\n     * @example\n     *\n     *     wordArray.clamp();\n     */\n    clamp() {\n        // Clamp\n        this.words[this.sigBytes >>> 2] &= 0xffffffff << (32 - (this.sigBytes % 4) * 8);\n        this.words.length = Math.ceil(this.sigBytes / 4);\n    }\n\n    /**\n     * Creates a copy of this word array.\n     *\n     * @return The clone.\n     *\n     * @example\n     *\n     *     let clone = wordArray.clone();\n     */\n    clone(): WordArray {\n        return new WordArray(this.words.slice(0), this.sigBytes);\n    }\n}","import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\n\ndeclare function escape(s: string): string;\ndeclare function unescape(s: string): string;\n\nexport class Latin1 {\n    /**\n     * Converts a word array to a Latin1 string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The Latin1 string.\n     *\n     * @example\n     *\n     *     let latin1String = Latin1.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        // Convert\n        const latin1Chars = [];\n        for (let i = 0; i < wordArray.sigBytes; i++) {\n            const bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            latin1Chars.push(String.fromCharCode(bite));\n        }\n\n        return latin1Chars.join('');\n    }\n\n    /**\n     * Converts a Latin1 string to a word array.\n     *\n     * @param latin1Str The Latin1 string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Latin1.parse(latin1String);\n     */\n    public static parse(latin1Str: string): WordArray {\n        // Shortcut\n        const latin1StrLength = latin1Str.length;\n\n        // Convert\n        const words: Array<number> = [];\n        for (let i = 0; i < latin1StrLength; i++) {\n            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n        }\n\n        return new WordArray(words, latin1StrLength);\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Latin1;","import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\nimport { Latin1 } from './Latin1';\n\nexport class Utf8 {\n    /**\n     * Converts a word array to a UTF-8 string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The UTF-8 string.\n     *\n     * @example\n     *\n     *     let utf8String = Utf8.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        try {\n            return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n        } catch(e) {\n            throw new Error('Malformed UTF-8 data');\n        }\n    }\n\n    /**\n     * Converts a UTF-8 string to a word array.\n     *\n     * @param utf8Str The UTF-8 string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Utf8.parse(utf8String);\n     */\n    public static parse(utf8Str: string): WordArray {\n        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Utf8;","import { WordArray } from '../lib/WordArray';\nimport { Utf8 } from '../enc/Utf8';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\n\nexport abstract class BufferedBlockAlgorithm {\n    public _minBufferSize = 0;\n\n    public _data: WordArray;\n\n    public _nDataBytes: number;\n\n    public cfg: BufferedBlockAlgorithmConfig;\n\n    abstract _doProcessBlock(wordArray: Array<number>, offset: number): void;\n\n    constructor(cfg?: BufferedBlockAlgorithmConfig) {\n        this.cfg = Object.assign({\n            blockSize: 1\n        }, cfg);\n\n        // Initial values\n        this._data = new WordArray();\n        this._nDataBytes = 0;\n    }\n\n    /**\n     * Resets this block algorithm's data buffer to its initial state.\n     *\n     * @example\n     *\n     *     bufferedBlockAlgorithm.reset();\n     */\n    reset() {\n        // Initial values\n        this._data = new WordArray();\n        this._nDataBytes = 0;\n    }\n\n    /**\n     * Adds new data to this block algorithm's buffer.\n     *\n     * @param data The data to append. Strings are converted to a WordArray using UTF-8.\n     *\n     * @example\n     *\n     *     bufferedBlockAlgorithm._append('data');\n     *     bufferedBlockAlgorithm._append(wordArray);\n     */\n    _append(data: string | WordArray) {\n        // Convert string to WordArray, else assume WordArray already\n        if(typeof data === 'string') {\n            data = Utf8.parse(data);\n        }\n\n        // Append\n        this._data.concat(data);\n        this._nDataBytes += data.sigBytes;\n    }\n\n    /**\n     * Processes available data blocks.\n     *\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n     *\n     * @param doFlush Whether all blocks and partial blocks should be processed.\n     *\n     * @return The processed data.\n     *\n     * @example\n     *\n     *     let processedData = bufferedBlockAlgorithm._process();\n     *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\n     */\n    _process(doFlush?: boolean): WordArray {\n        if(!this.cfg.blockSize) {\n            throw new Error('missing blockSize in config');\n        }\n\n        // Shortcuts\n        const blockSizeBytes = this.cfg.blockSize * 4;\n\n        // Count blocks ready\n        let nBlocksReady = this._data.sigBytes / blockSizeBytes;\n        if (doFlush) {\n            // Round up to include partial blocks\n            nBlocksReady = Math.ceil(nBlocksReady);\n        } else {\n            // Round down to include only full blocks,\n            // less the number of blocks that must remain in the buffer\n            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n        }\n\n        // Count words ready\n        const nWordsReady = nBlocksReady * this.cfg.blockSize;\n\n        // Count bytes ready\n        const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n\n        // Process blocks\n        let processedWords;\n        if (nWordsReady) {\n            for (let offset = 0; offset < nWordsReady; offset += this.cfg.blockSize) {\n                // Perform concrete-algorithm logic\n                this._doProcessBlock(this._data.words, offset);\n            }\n\n            // Remove processed words\n            processedWords = this._data.words.splice(0, nWordsReady);\n            this._data.sigBytes -= nBytesReady;\n        }\n\n        // Return processed words\n        return new WordArray(processedWords, nBytesReady);\n    }\n\n    /**\n     * Creates a copy of this object.\n     *\n     * @return The clone.\n     *\n     * @example\n     *\n     *     let clone = bufferedBlockAlgorithm.clone();\n     */\n    clone(): BufferedBlockAlgorithm {\n        const clone = this.constructor();\n\n        for(const attr in this) {\n            if(this.hasOwnProperty(attr)) {\n                clone[attr] = this[attr];\n            }\n        }\n\n        clone._data = this._data.clone();\n\n        return clone;\n    }\n}","export class Base {\n}","import { Base } from '../lib/Base';\nimport { CipherParamsInterface } from './CipherParamsInterface';\nimport { WordArray } from '../lib/WordArray';\nimport { Cipher } from '../lib/Cipher';\nimport { BlockCipherMode } from '../mode/BlockCipherMode';\nimport { Padding } from '../pad/Padding';\nimport { Formatter } from '../format/Formatter';\n\nexport class CipherParams extends Base implements CipherParamsInterface {\n    ciphertext?: WordArray;\n\n    key?: WordArray | string;\n\n    iv?: WordArray;\n\n    salt?: WordArray | string;\n\n    algorithm?: typeof Cipher;\n\n    mode?: typeof BlockCipherMode;\n\n    padding?: Padding;\n\n    blockSize?: number;\n\n    formatter?: Formatter;\n\n    /**\n     * Initializes a newly created cipher params object.\n     *\n     * @param cipherParams An object with any of the possible cipher parameters.\n     *\n     * @example\n     *\n     *     let cipherParams = CipherParams.create({\n     *         ciphertext: ciphertextWordArray,\n     *         key: keyWordArray,\n     *         iv: ivWordArray,\n     *         salt: saltWordArray,\n     *         algorithm: AESAlgorithm,\n     *         mode: CBC,\n     *         padding: PKCS7,\n     *         blockSize: 4,\n     *         formatter: OpenSSLFormatter\n     *     });\n     */\n    public constructor(cipherParams: CipherParamsInterface) {\n        super();\n\n        this.ciphertext = cipherParams.ciphertext;\n        this.key = cipherParams.key;\n        this.iv = cipherParams.iv;\n        this.salt = cipherParams.salt;\n        this.algorithm = cipherParams.algorithm;\n        this.mode = cipherParams.mode;\n        this.padding = cipherParams.padding;\n        this.blockSize = cipherParams.blockSize;\n        this.formatter = cipherParams.formatter;\n    }\n\n    public extend(additionalParams: CipherParams): CipherParams {\n        if(additionalParams.ciphertext !== undefined) {\n            this.ciphertext = additionalParams.ciphertext;\n        }\n\n        if(additionalParams.key !== undefined) {\n            this.key = additionalParams.key;\n        }\n\n        if(additionalParams.iv !== undefined) {\n            this.iv = additionalParams.iv;\n        }\n\n        if(additionalParams.salt !== undefined) {\n            this.salt = additionalParams.salt;\n        }\n\n        if(additionalParams.algorithm !== undefined) {\n            this.algorithm = additionalParams.algorithm;\n        }\n\n        if(additionalParams.mode !== undefined) {\n            this.mode = additionalParams.mode;\n        }\n\n        if(additionalParams.padding !== undefined) {\n            this.padding = additionalParams.padding;\n        }\n\n        if(additionalParams.blockSize !== undefined) {\n            this.blockSize = additionalParams.blockSize;\n        }\n\n        if(additionalParams.formatter !== undefined) {\n            this.formatter = additionalParams.formatter;\n        }\n\n\n        return this;\n    }\n\n    /**\n     * Converts this cipher params object to a string.\n     *\n     * @param formatter (Optional) The formatting strategy to use.\n     *\n     * @return The stringified cipher params.\n     *\n     * @throws Error If neither the formatter nor the default formatter is set.\n     *\n     * @example\n     *\n     *     let string = cipherParams + '';\n     *     let string = cipherParams.toString();\n     *     let string = cipherParams.toString(CryptoJS.format.OpenSSL);\n     */\n    public toString(formatter?: Formatter): string {\n        if(formatter) {\n            return formatter.stringify(this);\n        } else if(this.formatter) {\n            return this.formatter.stringify(this);\n        } else {\n            throw new Error('cipher needs a formatter to be able to convert the result into a string');\n        }\n    }\n}","import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\n\nexport class Base64 {\n    public static _map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n    public static _reverseMap: Array<number> | undefined = undefined;\n\n    /**\n     * Converts a word array to a Base64 string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The Base64 string.\n     *\n     * @example\n     *\n     *     let base64String = Base64.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        // Clamp excess bits\n        wordArray.clamp();\n\n        // Convert\n        const base64Chars = [];\n        for (let i = 0; i < wordArray.sigBytes; i += 3) {\n            const byte1 = (wordArray.words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n            const byte2 = (wordArray.words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n            const byte3 = (wordArray.words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n            const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n            for (let j = 0; (j < 4) && (i + j * 0.75 < wordArray.sigBytes); j++) {\n                base64Chars.push(this._map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n            }\n        }\n\n        // Add padding\n        const paddingChar = this._map.charAt(64);\n        if (paddingChar) {\n            while (base64Chars.length % 4) {\n                base64Chars.push(paddingChar);\n            }\n        }\n\n        return base64Chars.join('');\n    }\n\n    /**\n     * Converts a Base64 string to a word array.\n     *\n     * @param base64Str The Base64 string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Base64.parse(base64String);\n     */\n    public static parse(base64Str: string): WordArray {\n        // Shortcuts\n        let base64StrLength = base64Str.length;\n\n        if(this._reverseMap === undefined) {\n                this._reverseMap = [];\n                for(let j = 0; j < this._map.length; j++) {\n                    this._reverseMap[this._map.charCodeAt(j)] = j;\n                }\n        }\n\n        // Ignore padding\n        const paddingChar = this._map.charAt(64);\n        if(paddingChar) {\n            const paddingIndex = base64Str.indexOf(paddingChar);\n            if(paddingIndex !== -1) {\n                base64StrLength = paddingIndex;\n            }\n        }\n\n        // Convert\n        return this.parseLoop(base64Str, base64StrLength, this._reverseMap);\n    }\n\n    public static parseLoop(base64Str: string, base64StrLength: number, reverseMap: Array<number>): WordArray {\n        const words: Array<number> = [];\n        let nBytes = 0;\n        for(let i = 0; i < base64StrLength; i++) {\n            if(i % 4) {\n                const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n                const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n                words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);\n                nBytes++;\n            }\n        }\n\n        return new WordArray(words, nBytes);\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Base64;","import { Formatter } from './Formatter';\nimport { CipherParams } from '../lib/CipherParams';\nimport { WordArray } from '../lib/WordArray';\nimport { Base64 } from '../enc/Base64';\n\nexport class OpenSSL {\n    /**\n     * Converts a cipher params object to an OpenSSL-compatible string.\n     *\n     * @param cipherParams The cipher params object.\n     *\n     * @return The OpenSSL-compatible string.\n     *\n     * @example\n     *\n     *     let openSSLString = OpenSSLFormatter.stringify(cipherParams);\n     */\n    public static stringify(cipherParams: CipherParams): string {\n        if(!cipherParams.ciphertext) {\n            throw new Error('missing ciphertext in params');\n        }\n\n        // Shortcuts\n        const ciphertext = cipherParams.ciphertext;\n        const salt = cipherParams.salt;\n\n        // Format\n        let wordArray: WordArray;\n        if(salt) {\n            if(typeof salt === 'string') {\n                throw new Error('salt is expected to be a WordArray');\n            }\n\n            wordArray = (new WordArray([0x53616c74, 0x65645f5f])).concat(salt).concat(ciphertext);\n        } else {\n            wordArray = ciphertext;\n        }\n\n        return wordArray.toString(Base64);\n    }\n\n    /**\n     * Converts an OpenSSL-compatible string to a cipher params object.\n     *\n     * @param openSSLStr The OpenSSL-compatible string.\n     *\n     * @return The cipher params object.\n     *\n     * @example\n     *\n     *     let cipherParams = OpenSSLFormatter.parse(openSSLString);\n     */\n    public static parse(openSSLStr: string): CipherParams {\n        // Parse base64\n        const ciphertext = Base64.parse(openSSLStr);\n\n        // Test for salt\n        let salt: WordArray | undefined;\n        if(ciphertext.words[0] === 0x53616c74 && ciphertext.words[1] === 0x65645f5f) {\n            // Extract salt\n            salt = new WordArray(ciphertext.words.slice(2, 4));\n\n            // Remove salt from ciphertext\n            ciphertext.words.splice(0, 4);\n            ciphertext.sigBytes -= 16;\n        }\n\n        return new CipherParams({ ciphertext: ciphertext, salt: salt });\n    }\n}\n\n// type guard for OpenSSL formatter (to ensure it has the required static methods)\nconst _: Formatter = OpenSSL;","import { WordArray } from './WordArray';\nimport { Cipher } from './Cipher';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { OpenSSL } from '../format/OpenSSL';\nimport { CipherParams } from './CipherParams';\nimport { Formatter } from '../format/Formatter';\n\nexport class SerializableCipher {\n    public static cfg: BufferedBlockAlgorithmConfig = {\n        blockSize: 4,\n        iv: new WordArray([]),\n        format: OpenSSL\n    };\n\n    /**\n     * Encrypts a message.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param message The message to encrypt.\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher params object.\n     *\n     * @example\n     *\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, {\n     *       iv: iv,\n     *       format: CryptoJS.format.OpenSSL\n     *     });\n     */\n    public static encrypt(\n        cipher: typeof Cipher,\n        message: WordArray | string,\n        key: WordArray,\n        cfg?: BufferedBlockAlgorithmConfig\n    ): CipherParams {\n        // Apply config defaults\n        const config = Object.assign({}, this.cfg, cfg);\n\n        // Encrypt\n        const encryptor = cipher.createEncryptor(key, config);\n        const ciphertext = encryptor.finalize(message);\n\n        // Create and return serializable cipher params\n        return new CipherParams({\n            ciphertext: ciphertext,\n            key: key,\n            iv: encryptor.cfg.iv,\n            algorithm: cipher,\n            mode: (<any> encryptor.cfg).mode,\n            padding: (<any> encryptor.cfg).padding,\n            blockSize: encryptor.cfg.blockSize,\n            formatter: config.format\n        });\n    }\n\n    /**\n     * Decrypts serialized ciphertext.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param ciphertext The ciphertext to decrypt.\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return The plaintext.\n     *\n     * @example\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         formattedCiphertext,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         ciphertextParams,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     */\n    public static decrypt(\n        cipher: typeof Cipher,\n        ciphertext: CipherParams | string,\n        key: WordArray,\n        optionalCfg?: BufferedBlockAlgorithmConfig\n    ): WordArray {\n        // Apply config defaults\n        const cfg = Object.assign({}, this.cfg, optionalCfg);\n\n        if(!cfg.format) {\n            throw new Error('could not determine format');\n        }\n\n        // Convert string to CipherParams\n        ciphertext = this._parse(ciphertext, cfg.format);\n\n        if(!ciphertext.ciphertext) {\n            throw new Error('could not determine ciphertext');\n        }\n\n        // Decrypt\n        const plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n        return plaintext;\n    }\n\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * @param ciphertext The ciphertext.\n     * @param format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return The unserialized ciphertext.\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     */\n    public static _parse(ciphertext: CipherParams | string, format: Formatter): CipherParams {\n        if(typeof ciphertext === 'string') {\n            return format.parse(ciphertext);\n        } else {\n            return ciphertext;\n        }\n    }\n}","import { BufferedBlockAlgorithm } from '../lib/BufferedBlockAlgorithm';\nimport { BufferedBlockAlgorithmConfig } from '../lib/BufferedBlockAlgorithmConfig';\nimport { WordArray } from '../lib/WordArray';\n\nexport abstract class Hasher extends BufferedBlockAlgorithm {\n    /**\n     * Creates a shortcut function to a hasher's object interface.\n     *\n     * @param hasher The hasher to create a helper for.\n     *\n     * @return The shortcut function.\n     *\n     * @example\n     *\n     *     let SHA256 = Hasher._createHelper(SHA256);\n     */\n    public static _createHelper(hasher: typeof Hasher) {\n        function helper(message: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\n            const hasherClass: any = hasher;\n\n            const hasherInstance: any = new hasherClass(cfg);\n\n            return hasherInstance.finalize(message);\n        }\n\n        return helper;\n    }\n\n    /**\n     * Initializes a newly created hasher.\n     *\n     * @param cfg (Optional) The configuration options to use for this hash computation.\n     *\n     * @example\n     *\n     *     let hasher = CryptoJS.algo.SHA256.create();\n     */\n    public constructor(cfg?: BufferedBlockAlgorithmConfig) {\n        // Apply config defaults\n        super(Object.assign({\n            blockSize: 512 / 32\n        }, cfg));\n\n        // Set initial values\n        this.reset();\n    }\n\n    /**\n     * Updates this hasher with a message.\n     *\n     * @param messageUpdate The message to append.\n     *\n     * @return This hasher.\n     *\n     * @example\n     *\n     *     hasher.update('message');\n     *     hasher.update(wordArray);\n     */\n    update(messageUpdate: WordArray | string): Hasher {\n        // Append\n        this._append(messageUpdate);\n\n        // Update the hash\n        this._process();\n\n        // Chainable\n        return this;\n    }\n\n    /**\n     * Finalizes the hash computation.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * @param messageUpdate (Optional) A final message update.\n     *\n     * @return The hash.\n     *\n     * @example\n     *\n     *     let hash = hasher.finalize();\n     *     let hash = hasher.finalize('message');\n     *     let hash = hasher.finalize(wordArray);\n     */\n    public finalize(messageUpdate: WordArray | string): WordArray {\n        // Final message update\n        if(messageUpdate) {\n            this._append(messageUpdate);\n        }\n\n        // Perform concrete-hasher logic\n        const hash = this._doFinalize();\n\n        return hash;\n    }\n\n    public abstract _doFinalize(): WordArray;\n}","import { Hasher } from '../lib/Hasher';\nimport { WordArray } from '../lib/WordArray';\n\n// Constants table\nconst T: Array<number> = [];\n\n// Compute constants\nfor(let i = 0; i < 64; i++) {\n    T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\n\nexport class MD5 extends Hasher {\n    public _hash!: WordArray;\n\n    public static FF(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + ((b & c) | (~b & d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public static GG(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + ((b & d) | (c & ~d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public static HH(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + (b ^ c ^ d) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public static II(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + (c ^ (b | ~d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public reset() {\n        // reset core values\n        super.reset();\n\n        this._hash = new WordArray([\n            0x67452301, 0xefcdab89,\n            0x98badcfe, 0x10325476\n        ]);\n    }\n\n    public _doProcessBlock(M: Array<number>, offset: number) {\n        // Swap endian\n        for(let i = 0; i < 16; i++) {\n            // Shortcuts\n            const offset_i = offset + i;\n            const M_offset_i = M[offset_i];\n\n            M[offset_i] = (\n                (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n                (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n            );\n        }\n\n        // Shortcuts\n        const H = this._hash.words;\n\n        const M_offset_0  = M[offset + 0];\n        const M_offset_1  = M[offset + 1];\n        const M_offset_2  = M[offset + 2];\n        const M_offset_3  = M[offset + 3];\n        const M_offset_4  = M[offset + 4];\n        const M_offset_5  = M[offset + 5];\n        const M_offset_6  = M[offset + 6];\n        const M_offset_7  = M[offset + 7];\n        const M_offset_8  = M[offset + 8];\n        const M_offset_9  = M[offset + 9];\n        const M_offset_10 = M[offset + 10];\n        const M_offset_11 = M[offset + 11];\n        const M_offset_12 = M[offset + 12];\n        const M_offset_13 = M[offset + 13];\n        const M_offset_14 = M[offset + 14];\n        const M_offset_15 = M[offset + 15];\n\n        // Working variables\n        let a = H[0];\n        let b = H[1];\n        let c = H[2];\n        let d = H[3];\n\n        // Computation\n        a = MD5.FF(a, b, c, d, M_offset_0,  7,  T[0]);\n        d = MD5.FF(d, a, b, c, M_offset_1,  12, T[1]);\n        c = MD5.FF(c, d, a, b, M_offset_2,  17, T[2]);\n        b = MD5.FF(b, c, d, a, M_offset_3,  22, T[3]);\n        a = MD5.FF(a, b, c, d, M_offset_4,  7,  T[4]);\n        d = MD5.FF(d, a, b, c, M_offset_5,  12, T[5]);\n        c = MD5.FF(c, d, a, b, M_offset_6,  17, T[6]);\n        b = MD5.FF(b, c, d, a, M_offset_7,  22, T[7]);\n        a = MD5.FF(a, b, c, d, M_offset_8,  7,  T[8]);\n        d = MD5.FF(d, a, b, c, M_offset_9,  12, T[9]);\n        c = MD5.FF(c, d, a, b, M_offset_10, 17, T[10]);\n        b = MD5.FF(b, c, d, a, M_offset_11, 22, T[11]);\n        a = MD5.FF(a, b, c, d, M_offset_12, 7,  T[12]);\n        d = MD5.FF(d, a, b, c, M_offset_13, 12, T[13]);\n        c = MD5.FF(c, d, a, b, M_offset_14, 17, T[14]);\n        b = MD5.FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n        a = MD5.GG(a, b, c, d, M_offset_1,  5,  T[16]);\n        d = MD5.GG(d, a, b, c, M_offset_6,  9,  T[17]);\n        c = MD5.GG(c, d, a, b, M_offset_11, 14, T[18]);\n        b = MD5.GG(b, c, d, a, M_offset_0,  20, T[19]);\n        a = MD5.GG(a, b, c, d, M_offset_5,  5,  T[20]);\n        d = MD5.GG(d, a, b, c, M_offset_10, 9,  T[21]);\n        c = MD5.GG(c, d, a, b, M_offset_15, 14, T[22]);\n        b = MD5.GG(b, c, d, a, M_offset_4,  20, T[23]);\n        a = MD5.GG(a, b, c, d, M_offset_9,  5,  T[24]);\n        d = MD5.GG(d, a, b, c, M_offset_14, 9,  T[25]);\n        c = MD5.GG(c, d, a, b, M_offset_3,  14, T[26]);\n        b = MD5.GG(b, c, d, a, M_offset_8,  20, T[27]);\n        a = MD5.GG(a, b, c, d, M_offset_13, 5,  T[28]);\n        d = MD5.GG(d, a, b, c, M_offset_2,  9,  T[29]);\n        c = MD5.GG(c, d, a, b, M_offset_7,  14, T[30]);\n        b = MD5.GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n        a = MD5.HH(a, b, c, d, M_offset_5,  4,  T[32]);\n        d = MD5.HH(d, a, b, c, M_offset_8,  11, T[33]);\n        c = MD5.HH(c, d, a, b, M_offset_11, 16, T[34]);\n        b = MD5.HH(b, c, d, a, M_offset_14, 23, T[35]);\n        a = MD5.HH(a, b, c, d, M_offset_1,  4,  T[36]);\n        d = MD5.HH(d, a, b, c, M_offset_4,  11, T[37]);\n        c = MD5.HH(c, d, a, b, M_offset_7,  16, T[38]);\n        b = MD5.HH(b, c, d, a, M_offset_10, 23, T[39]);\n        a = MD5.HH(a, b, c, d, M_offset_13, 4,  T[40]);\n        d = MD5.HH(d, a, b, c, M_offset_0,  11, T[41]);\n        c = MD5.HH(c, d, a, b, M_offset_3,  16, T[42]);\n        b = MD5.HH(b, c, d, a, M_offset_6,  23, T[43]);\n        a = MD5.HH(a, b, c, d, M_offset_9,  4,  T[44]);\n        d = MD5.HH(d, a, b, c, M_offset_12, 11, T[45]);\n        c = MD5.HH(c, d, a, b, M_offset_15, 16, T[46]);\n        b = MD5.HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n        a = MD5.II(a, b, c, d, M_offset_0,  6,  T[48]);\n        d = MD5.II(d, a, b, c, M_offset_7,  10, T[49]);\n        c = MD5.II(c, d, a, b, M_offset_14, 15, T[50]);\n        b = MD5.II(b, c, d, a, M_offset_5,  21, T[51]);\n        a = MD5.II(a, b, c, d, M_offset_12, 6,  T[52]);\n        d = MD5.II(d, a, b, c, M_offset_3,  10, T[53]);\n        c = MD5.II(c, d, a, b, M_offset_10, 15, T[54]);\n        b = MD5.II(b, c, d, a, M_offset_1,  21, T[55]);\n        a = MD5.II(a, b, c, d, M_offset_8,  6,  T[56]);\n        d = MD5.II(d, a, b, c, M_offset_15, 10, T[57]);\n        c = MD5.II(c, d, a, b, M_offset_6,  15, T[58]);\n        b = MD5.II(b, c, d, a, M_offset_13, 21, T[59]);\n        a = MD5.II(a, b, c, d, M_offset_4,  6,  T[60]);\n        d = MD5.II(d, a, b, c, M_offset_11, 10, T[61]);\n        c = MD5.II(c, d, a, b, M_offset_2,  15, T[62]);\n        b = MD5.II(b, c, d, a, M_offset_9,  21, T[63]);\n\n        // Intermediate hash value\n        H[0] = (H[0] + a) | 0;\n        H[1] = (H[1] + b) | 0;\n        H[2] = (H[2] + c) | 0;\n        H[3] = (H[3] + d) | 0;\n    }\n\n    public _doFinalize(): WordArray {\n        // Shortcuts\n        const data = this._data;\n        const dataWords = data.words;\n\n        const nBitsTotal = this._nDataBytes * 8;\n        const nBitsLeft = data.sigBytes * 8;\n\n        // Add padding\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n        const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n        const nBitsTotalL = nBitsTotal;\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n            (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n        );\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n            (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n        );\n\n        data.sigBytes = (dataWords.length + 1) * 4;\n\n        // Hash final blocks\n        this._process();\n\n        // Shortcuts\n        const hash = this._hash;\n        const H = hash.words;\n\n        // Swap endian\n        for (let i = 0; i < 4; i++) {\n            // Shortcut\n            const H_i = H[i];\n\n            H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n                   (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n        }\n\n        // Return final computed hash\n        return hash;\n    }\n}","import { WordArray } from '../lib/WordArray';\nimport { Hasher } from '../lib/Hasher';\nimport { MD5 } from '../algo/MD5';\n\nexport interface OptionalEvpKDFConfig {\n    keySize?: number;\n    hasher?: typeof Hasher;\n    iterations?: number;\n}\n\nexport interface EvpKDFConfig extends OptionalEvpKDFConfig {\n    keySize: number;\n    hasher: typeof Hasher;\n    iterations: number;\n}\n\nexport class EvpKDF {\n    public cfg: EvpKDFConfig;\n\n    /**\n     * Initializes a newly created key derivation function.\n     *\n     * @param cfg (Optional) The configuration options to use for the derivation.\n     *\n     * @example\n     *\n     *     let kdf = EvpKDF.create();\n     *     let kdf = EvpKDF.create({ keySize: 8 });\n     *     let kdf = EvpKDF.create({ keySize: 8, iterations: 1000 });\n     */\n    constructor(cfg?: OptionalEvpKDFConfig) {\n        this.cfg = Object.assign({\n            keySize: 128 / 32,\n            hasher: MD5,\n            iterations: 1\n        }, cfg);\n    }\n\n    /**\n     * Derives a key from a password.\n     *\n     * @param password The password.\n     * @param salt A salt.\n     *\n     * @return The derived key.\n     *\n     * @example\n     *\n     *     let key = kdf.compute(password, salt);\n     */\n    compute(password: WordArray | string, salt: WordArray | string): WordArray {\n        // Init hasher\n        const hasher = new (<any> this.cfg.hasher)();\n\n        // Initial values\n        const derivedKey = new WordArray();\n\n        // Generate key\n        let block;\n        while(derivedKey.words.length < this.cfg.keySize) {\n            if(block) {\n                hasher.update(block);\n            }\n            block = hasher.update(password).finalize(salt);\n            hasher.reset();\n\n            // Iterations\n            for(let i = 1; i < this.cfg.iterations; i++) {\n                block = hasher.finalize(block);\n                hasher.reset();\n            }\n\n            derivedKey.concat(block);\n        }\n        derivedKey.sigBytes = this.cfg.keySize * 4;\n\n        return derivedKey;\n    }\n}","import { KDF } from './KDF';\nimport { WordArray } from '../lib/WordArray';\nimport { CipherParams } from '../lib/CipherParams';\nimport { EvpKDF } from '../algo/EvpKDF';\n\nexport class OpenSSLKdf {\n    /**\n     * Derives a key and IV from a password.\n     *\n     * @param password The password to derive from.\n     * @param keySize The size in words of the key to generate.\n     * @param ivSize The size in words of the IV to generate.\n     * @param salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n     *\n     * @return A cipher params object with the key, IV, and salt.\n     *\n     * @example\n     *\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32);\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n     */\n    public static execute(password: string, keySize: number, ivSize: number, salt?: WordArray | string): CipherParams {\n        // Generate random salt\n        if(!salt) {\n            salt = WordArray.random(64 / 8);\n        }\n\n        // Derive key and IV\n        const key = (new EvpKDF({ keySize: keySize + ivSize })).compute(password, salt);\n\n        // Separate key and IV\n        const iv = new WordArray(key.words.slice(keySize), ivSize * 4);\n        key.sigBytes = keySize * 4;\n\n        // Return params\n        return new CipherParams({ key: key, iv: iv, salt: salt });\n    }\n}\n\nconst _: KDF = OpenSSLKdf;","import { SerializableCipher } from './SerializableCipher';\nimport { WordArray } from './WordArray';\nimport { Cipher } from './Cipher';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { OpenSSL } from '../format/OpenSSL';\nimport { CipherParams } from './CipherParams';\nimport { Formatter } from '../format/Formatter';\nimport { OpenSSLKdf } from '../kdf/OpenSSLKdf';\n\nexport class PasswordBasedCipher {\n    public static cfg: BufferedBlockAlgorithmConfig = {\n        blockSize: 4,\n        iv: new WordArray([]),\n        format: OpenSSL,\n        kdf: OpenSSLKdf\n    };\n\n    /**\n     * Encrypts a message using a password.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param message The message to encrypt.\n     * @param password The password.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher params object.\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password');\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password', { format: OpenSSL });\n     */\n    public static encrypt(\n        cipher: typeof Cipher,\n        message: WordArray | string,\n        password: string,\n        cfg?: BufferedBlockAlgorithmConfig\n    ): CipherParams {\n        // Apply config defaults\n        const config = Object.assign({}, this.cfg, cfg);\n\n        // Check if we have a kdf\n        if(config.kdf === undefined) {\n            throw new Error('missing kdf in config');\n        }\n\n        // Derive key and other params\n        const derivedParams: CipherParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n        // Check if we have an IV\n        if(derivedParams.iv !== undefined) {\n            // Add IV to config\n            config.iv = derivedParams.iv;\n        }\n\n        // Encrypt\n        const ciphertext: CipherParams = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, config);\n\n        // Mix in derived params\n        return ciphertext.extend(derivedParams);\n    }\n\n    /**\n     * Decrypts serialized ciphertext using a password.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param ciphertext The ciphertext to decrypt.\n     * @param password The password.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return The plaintext.\n     *\n     * @example\n     *\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, formattedCiphertext, 'password', { format: OpenSSL });\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, ciphertextParams, 'password', { format: OpenSSL });\n     */\n    public static decrypt(\n        cipher: typeof Cipher,\n        ciphertext: CipherParams | string,\n        password: string,\n        cfg?: BufferedBlockAlgorithmConfig\n    ): WordArray {\n        // Apply config defaults\n        const config = Object.assign({}, this.cfg, cfg);\n\n        // Check if we have a kdf\n        if(config.format === undefined) {\n            throw new Error('missing format in config');\n        }\n\n        // Convert string to CipherParams\n        ciphertext = this._parse(ciphertext, config.format);\n\n        // Check if we have a kdf\n        if(config.kdf === undefined) {\n            throw new Error('the key derivation function must be set');\n        }\n\n        // Derive key and other params\n        const derivedParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n\n        // Check if we have an IV\n        if(derivedParams.iv !== undefined) {\n            // Add IV to config\n            config.iv = derivedParams.iv;\n        }\n\n        // Decrypt\n        const plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, config);\n\n        return plaintext;\n    }\n\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * @param ciphertext The ciphertext.\n     * @param format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return The unserialized ciphertext.\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     */\n    public static _parse(ciphertext: CipherParams | string, format: Formatter): CipherParams {\n        if(typeof ciphertext === 'string') {\n            return format.parse(ciphertext);\n        } else {\n            return ciphertext;\n        }\n    }\n}","import { BufferedBlockAlgorithm } from './BufferedBlockAlgorithm';\nimport { WordArray } from './WordArray';\nimport { SerializableCipher } from './SerializableCipher';\nimport { PasswordBasedCipher } from './PasswordBasedCipher';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { CipherParams } from './CipherParams';\n\nexport abstract class Cipher extends BufferedBlockAlgorithm {\n    /**\n     * A constant representing encryption mode.\n     */\n    public static _ENC_XFORM_MODE = 1;\n\n    /**\n     * A constant representing decryption mode.\n     */\n    public static _DEC_XFORM_MODE = 2;\n\n    /**\n     * This cipher's key size. Default: 4 (128 bits / 32 Bits)\n     */\n    public static keySize = 4;\n\n    /**\n     * This cipher's IV size. Default: 4 (128 bits / 32 Bits)\n     */\n    public static ivSize = 4;\n\n    /**\n     * Either the encryption or decryption transformation mode constant.\n     */\n    public _xformMode: number;\n\n    /**\n     * The key.\n     */\n    public _key: WordArray;\n\n    /**\n     * Creates this cipher in encryption mode.\n     *\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher instance.\n     *\n     * @example\n     *\n     *     let cipher = AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n     */\n    public static createEncryptor(key: WordArray, cfg?: BufferedBlockAlgorithmConfig): Cipher {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const thisClass: any = this;\n\n        return new thisClass(this._ENC_XFORM_MODE, key, cfg);\n    }\n\n    /**\n     * Creates this cipher in decryption mode.\n     *\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher instance.\n     *\n     * @example\n     *\n     *     let cipher = AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n     */\n    public static createDecryptor(key: WordArray, cfg?: BufferedBlockAlgorithmConfig): Cipher {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const thisClass: any = this;\n\n        return new thisClass(this._DEC_XFORM_MODE, key, cfg);\n    }\n\n    /**\n     * Creates shortcut functions to a cipher's object interface.\n     *\n     * @param cipher The cipher to create a helper for.\n     *\n     * @return An object with encrypt and decrypt shortcut functions.\n     *\n     * @example\n     *\n     *     let AES = Cipher._createHelper(AESAlgorithm);\n     */\n    public static _createHelper(cipher: typeof Cipher) {\n        function encrypt(message: WordArray | string, key: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\n            if(typeof key === 'string') {\n                return PasswordBasedCipher.encrypt(cipher, message, key, cfg);\n            } else {\n                return SerializableCipher.encrypt(cipher, message, key, cfg);\n            }\n        }\n\n        function decrypt(ciphertext: CipherParams | string, key: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\n            if(typeof key === 'string') {\n                return PasswordBasedCipher.decrypt(cipher, ciphertext, key, cfg);\n            } else {\n                return SerializableCipher.decrypt(cipher, ciphertext, key, cfg);\n            }\n        }\n\n        return {\n            encrypt: encrypt,\n            decrypt: decrypt\n        };\n    }\n\n    /**\n     * Initializes a newly created cipher.\n     *\n     * @param xformMode Either the encryption or decryption transormation mode constant.\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @example\n     *\n     *     let cipher = AES.create(AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n     */\n    public constructor(xformMode: number, key: WordArray, cfg?: BufferedBlockAlgorithmConfig) {\n        // Apply config defaults\n        super(Object.assign({\n            blockSize: 1\n        }, cfg));\n\n        // Store transform mode and key\n        this._xformMode = xformMode;\n        this._key = key;\n\n        // Set initial values\n        this.reset();\n    }\n\n    /**\n     * Adds data to be encrypted or decrypted.\n     *\n     * @param dataUpdate The data to encrypt or decrypt.\n     *\n     * @return The data after processing.\n     *\n     * @example\n     *\n     *     let encrypted = cipher.process('data');\n     *     let encrypted = cipher.process(wordArray);\n     */\n    public process(dataUpdate: WordArray | string): WordArray {\n        // Append\n        this._append(dataUpdate);\n\n        // Process available blocks\n        return this._process();\n    }\n\n    /**\n     * Finalizes the encryption or decryption process.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * @param dataUpdate The final data to encrypt or decrypt.\n     *\n     * @return The data after final processing.\n     *\n     * @example\n     *\n     *     var encrypted = cipher.finalize();\n     *     var encrypted = cipher.finalize('data');\n     *     var encrypted = cipher.finalize(wordArray);\n     */\n    public finalize(dataUpdate?: WordArray | string): WordArray {\n        // Final data update\n        if(dataUpdate) {\n            this._append(dataUpdate);\n        }\n\n        // Perform concrete-cipher logic\n        const finalProcessedData = this._doFinalize();\n\n        return finalProcessedData;\n    }\n\n    /**\n     * Cipher specific finalize function explicitly implemented in the derived class.\n     */\n    public abstract _doFinalize(): WordArray;\n}","import { BlockCipher } from '../lib/BlockCipher';\nimport { BlockCipherMode } from './BlockCipherMode';\n\nexport abstract class BlockCipherModeAlgorithm {\n    public _cipher!: BlockCipher;\n\n    public _iv: Array<number> | undefined;\n\n    public __creator: ((cipher: BlockCipher, iv: number[]) => BlockCipherMode) | undefined;\n\n    public constructor(cipher: BlockCipher, iv: Array<number>) {\n        this.init(cipher, iv);\n    }\n\n    /**\n     * Initializes a newly created mode.\n     *\n     * @param cipher A block cipher instance.\n     * @param iv The IV words.\n     *\n     * @example\n     *\n     *     var mode = CBC.Encryptor.create(cipher, iv.words);\n     */\n    public init(cipher: BlockCipher, iv?: Array<number>) {\n        this._cipher = cipher;\n        this._iv = iv;\n    }\n\n    public abstract processBlock(words: Array<number>, offset: number): void;\n}","import { BlockCipher } from '../lib/BlockCipher';\nimport { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport abstract class BlockCipherMode {\n    public static Encryptor: any = BlockCipherModeAlgorithm;\n\n    public static Decryptor: any = BlockCipherModeAlgorithm;\n\n    /**\n     * Creates this mode for encryption.\n     *\n     * @param cipher A block cipher instance.\n     * @param iv The IV words.\n     *\n     * @example\n     *\n     *     var mode = CBC.createEncryptor(cipher, iv.words);\n     */\n    public static createEncryptor(cipher: BlockCipher, iv: Array<number>): BlockCipherModeAlgorithm {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const encryptorClass: any = this.Encryptor;\n\n        return new encryptorClass(cipher, iv);\n    }\n\n    /**\n     * Creates this mode for decryption.\n     *\n     * @param cipher A block cipher instance.\n     * @param iv The IV words.\n     *\n     * @example\n     *\n     *     var mode = CBC.createDecryptor(cipher, iv.words);\n     */\n    public static createDecryptor(cipher: BlockCipher, iv: Array<number>): BlockCipherModeAlgorithm {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const decryptorClass: any = this.Decryptor;\n\n        return new decryptorClass(cipher, iv);\n    }\n}","import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class CBCEncryptor extends BlockCipherModeAlgorithm {\n    public _prevBlock: Array<number> | undefined;\n\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        // Check if we have a blockSize\n        if(this._cipher.cfg.blockSize === undefined) {\n            throw new Error('missing blockSize in cipher config');\n        }\n\n        // XOR and encrypt\n        this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n        this._cipher.encryptBlock(words, offset);\n\n        // Remember this block to use with next block\n        this._prevBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n    }\n\n    public xorBlock(words: Array<number>, offset: number, blockSize: number) {\n        // Choose mixing block\n        let block;\n        if(this._iv) {\n            block = this._iv;\n\n            // Remove IV for subsequent blocks\n            this._iv = undefined;\n        } else {\n            block = this._prevBlock;\n        }\n\n        // block should never be undefined but we want to make typescript happy\n        if(block !== undefined) {\n            // XOR blocks\n            for(let i = 0; i < blockSize; i++) {\n                words[offset + i] ^= block[i];\n            }\n        }\n    }\n}","import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class CBCDecryptor extends BlockCipherModeAlgorithm {\n    public _prevBlock: Array<number> | undefined;\n\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        // Check if we have a blockSize\n        if(this._cipher.cfg.blockSize === undefined) {\n            throw new Error('missing blockSize in cipher config');\n        }\n\n        // Remember this block to use with next block\n        const thisBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n\n        // Decrypt and XOR\n        this._cipher.decryptBlock(words, offset);\n        this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n\n        // This block becomes the previous block\n        this._prevBlock = thisBlock;\n    }\n\n    public xorBlock(words: Array<number>, offset: number, blockSize: number) {\n        // Choose mixing block\n        let block;\n        if(this._iv) {\n            block = this._iv;\n\n            // Remove IV for subsequent blocks\n            this._iv = undefined;\n        } else {\n            block = this._prevBlock;\n        }\n\n        // block should never be undefined but we want to make typescript happy\n        if(block !== undefined) {\n            // XOR blocks\n            for(let i = 0; i < blockSize; i++) {\n                words[offset + i] ^= block[i];\n            }\n        }\n    }\n}","import { BlockCipherMode } from './BlockCipherMode';\nimport { CBCEncryptor } from './CBCEncryptor';\nimport { CBCDecryptor } from './CBCDecryptor';\n\n/**\n * Cipher Block Chaining mode.\n */\nexport abstract class CBC extends BlockCipherMode {\n    public static Encryptor: any = CBCEncryptor;\n\n    public static Decryptor: any = CBCDecryptor;\n}","import { WordArray } from '../lib/WordArray';\nimport { Padding } from '../pad/Padding';\n\nexport class PKCS7 {\n    /**\n     * Pads data using the algorithm defined in PKCS #5/7.\n     *\n     * @param data The data to pad.\n     * @param blockSize The multiple that the data should be padded to.\n     *\n     * @example\n     *\n     *     PKCS7.pad(wordArray, 4);\n     */\n    public static pad(data: WordArray, blockSize: number): void {\n        // Shortcut\n        const blockSizeBytes = blockSize * 4;\n\n        // Count padding bytes\n        const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n        // Create padding word\n        const paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n        // Create padding\n        const paddingWords = [];\n        for (let i = 0; i < nPaddingBytes; i += 4) {\n            paddingWords.push(paddingWord);\n        }\n        const padding = new WordArray(paddingWords, nPaddingBytes);\n\n        // Add padding\n        data.concat(padding);\n    }\n\n    /**\n     * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n     *\n     * @param data The data to unpad.\n     *\n     * @example\n     *\n     *     PKCS7.unpad(wordArray);\n     */\n    public static unpad(data: WordArray): void {\n        // Get number of padding bytes from last byte\n        const nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n        // Remove padding\n        data.sigBytes -= nPaddingBytes;\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Padding = PKCS7;","import { Cipher } from './Cipher';\nimport { WordArray } from './WordArray';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { BlockCipherModeAlgorithm } from '../mode/BlockCipherModeAlgorithm';\nimport { CBC } from '../mode/CBC';\nimport { PKCS7 } from '../pad/PKCS7';\n\nexport abstract class BlockCipher extends Cipher {\n    public _mode!: BlockCipherModeAlgorithm;\n\n    constructor(xformMode: number, key: WordArray, cfg?: BufferedBlockAlgorithmConfig) {\n        super(xformMode, key, Object.assign({\n            // default: 128 / 32\n            blockSize: 4,\n            mode: CBC,\n            padding: PKCS7\n        }, cfg));\n    }\n\n    public reset() {\n        // Reset cipher\n        super.reset();\n\n        // Check if we have a blockSize\n        if(this.cfg.mode === undefined) {\n            throw new Error('missing mode in config');\n        }\n\n        // Reset block mode\n        let modeCreator;\n        if (this._xformMode === (<typeof BlockCipher> this.constructor)._ENC_XFORM_MODE) {\n            modeCreator = this.cfg.mode.createEncryptor;\n        } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n            modeCreator = this.cfg.mode.createDecryptor;\n            // Keep at least one block in the buffer for unpadding\n            this._minBufferSize = 1;\n        }\n\n        if (this._mode && this._mode.__creator === modeCreator) {\n            this._mode.init(this, this.cfg.iv && this.cfg.iv.words);\n        } else {\n            this._mode = modeCreator.call(this.cfg.mode, this, this.cfg.iv && this.cfg.iv.words);\n            this._mode.__creator = modeCreator;\n        }\n    }\n\n    _doProcessBlock(words: Array<number>, offset: number) {\n        this._mode.processBlock(words, offset);\n    }\n\n    _doFinalize() {\n        // Check if we have a padding strategy\n        if(this.cfg.padding === undefined) {\n            throw new Error('missing padding in config');\n        }\n\n        // Finalize\n        let finalProcessedBlocks;\n        if(this._xformMode === (<typeof BlockCipher> this.constructor)._ENC_XFORM_MODE) {\n            // Check if we have a blockSize\n            if(this.cfg.blockSize === undefined) {\n                throw new Error('missing blockSize in config');\n            }\n\n            // Pad data\n            this.cfg.padding.pad(this._data, this.cfg.blockSize);\n\n            // Process final blocks\n            finalProcessedBlocks = this._process(!!'flush');\n        } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n            // Process final blocks\n            finalProcessedBlocks = this._process(!!'flush');\n\n            // Unpad data\n            this.cfg.padding.unpad(finalProcessedBlocks);\n        }\n\n        return finalProcessedBlocks;\n    }\n\n    public abstract encryptBlock(M: Array<number>, offset: number): void;\n\n    public abstract decryptBlock(M: Array<number>, offset: number): void;\n}","import { BlockCipher } from '../lib/BlockCipher';\nimport { WordArray } from '../lib/WordArray';\nimport { BufferedBlockAlgorithmConfig } from '../lib/BufferedBlockAlgorithmConfig';\n\n// Define lookup tables\nconst SBOX: Array<number> = [];\nconst INV_SBOX: Array<number> = [];\nconst SUB_MIX_0: Array<number> = [];\nconst SUB_MIX_1: Array<number> = [];\nconst SUB_MIX_2: Array<number> = [];\nconst SUB_MIX_3: Array<number> = [];\nconst INV_SUB_MIX_0: Array<number> = [];\nconst INV_SUB_MIX_1: Array<number> = [];\nconst INV_SUB_MIX_2: Array<number> = [];\nconst INV_SUB_MIX_3: Array<number> = [];\n\n// Compute lookup tables\n(function () {\n    // Compute double table\n    const d = [];\n    for (let i = 0; i < 256; i++) {\n        if (i < 128) {\n            d[i] = i << 1;\n        } else {\n            d[i] = (i << 1) ^ 0x11b;\n        }\n    }\n\n    // Walk GF(2^8)\n    let x = 0;\n    let xi = 0;\n    for (let i = 0; i < 256; i++) {\n        // Compute sbox\n        let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n        SBOX[x] = sx;\n        INV_SBOX[sx] = x;\n\n        // Compute multiplication\n        const x2 = d[x];\n        const x4 = d[x2];\n        const x8 = d[x4];\n\n        // Compute sub bytes, mix columns tables\n        let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n        SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n        SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n        SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\n        SUB_MIX_3[x] = t;\n\n        // Compute inv sub bytes, inv mix columns tables\n        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n        INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n        INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n        INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\n        INV_SUB_MIX_3[sx] = t;\n\n        // Compute next counter\n        if (!x) {\n            x = xi = 1;\n        } else {\n            x = x2 ^ d[d[d[x8 ^ x2]]];\n            xi ^= d[d[xi]];\n        }\n    }\n}());\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\nexport class AES extends BlockCipher {\n    // 256 / 32\n    public static keySize = 8;\n\n    _nRounds!: number;\n\n    _key!: WordArray;\n\n    _keyPriorReset!: WordArray;\n\n    _keySchedule!: Array<number>;\n\n    _invKeySchedule!: Array<number>;\n\n    constructor(xformMode: number, key: WordArray, cfg?: BufferedBlockAlgorithmConfig) {\n        super(xformMode, key, cfg);\n    }\n\n    reset() {\n        // reset core values\n        super.reset();\n\n        // Skip reset of nRounds has been set before and key did not change\n        if (this._nRounds && this._keyPriorReset === this._key) {\n            return;\n        }\n\n        // Shortcuts\n        const key = this._keyPriorReset = this._key;\n        const keyWords = key.words;\n        const keySize = key.sigBytes / 4;\n\n        // Compute number of rounds\n        const nRounds = this._nRounds = keySize + 6;\n\n        // Compute number of key schedule rows\n        const ksRows = (nRounds + 1) * 4;\n\n        // Compute key schedule\n        const keySchedule: Array<number> = this._keySchedule = [];\n        for (let ksRow = 0; ksRow < ksRows; ksRow++) {\n            if (ksRow < keySize) {\n                keySchedule[ksRow] = keyWords[ksRow];\n            } else {\n                let t = keySchedule[ksRow - 1];\n\n                if (!(ksRow % keySize)) {\n                    // Rot word\n                    t = (t << 8) | (t >>> 24);\n\n                    // Sub word\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\n                    // Mix Rcon\n                    t ^= RCON[(ksRow / keySize) | 0] << 24;\n                } else if (keySize > 6 && ksRow % keySize === 4) {\n                    // Sub word\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n                }\n\n                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n            }\n        }\n\n        // Compute inv key schedule\n        const invKeySchedule: Array<number> = this._invKeySchedule = [];\n        for (let invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n            const ksRow = ksRows - invKsRow;\n\n            let t;\n            if (invKsRow % 4) {\n                t = keySchedule[ksRow];\n            } else {\n                t = keySchedule[ksRow - 4];\n            }\n\n            if (invKsRow < 4 || ksRow <= 4) {\n                invKeySchedule[invKsRow] = t;\n            } else {\n                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n                                           INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n            }\n        }\n    }\n\n    encryptBlock(M: Array<number>, offset: number) {\n        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n    }\n\n    decryptBlock(M: Array<number>, offset: number) {\n        // Swap 2nd and 4th rows\n        let t = M[offset + 1];\n        M[offset + 1] = M[offset + 3];\n        M[offset + 3] = t;\n\n        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n        // Inv swap 2nd and 4th rows\n        t = M[offset + 1];\n        M[offset + 1] = M[offset + 3];\n        M[offset + 3] = t;\n    }\n\n    _doCryptBlock(\n        M: Array<number>,\n        offset: number,\n        keySchedule: Array<number>,\n        sub_mix_0: Array<number>,\n        sub_mix_1: Array<number>,\n        sub_mix_2: Array<number>,\n        sub_mix_3: Array<number>,\n        sbox: Array<number>\n    ) {\n        // Get input, add round key\n        let s0 = M[offset]     ^ keySchedule[0];\n        let s1 = M[offset + 1] ^ keySchedule[1];\n        let s2 = M[offset + 2] ^ keySchedule[2];\n        let s3 = M[offset + 3] ^ keySchedule[3];\n\n        // Key schedule row counter\n        let ksRow = 4;\n\n        // Rounds\n        for (let round = 1; round < this._nRounds; round++) {\n            // Shift rows, sub bytes, mix columns, add round key\n            const t0 = sub_mix_0[s0 >>> 24] ^ sub_mix_1[(s1 >>> 16) & 0xff] ^ sub_mix_2[(s2 >>> 8) & 0xff] ^ sub_mix_3[s3 & 0xff] ^\n                     keySchedule[ksRow++];\n            const t1 = sub_mix_0[s1 >>> 24] ^ sub_mix_1[(s2 >>> 16) & 0xff] ^ sub_mix_2[(s3 >>> 8) & 0xff] ^ sub_mix_3[s0 & 0xff] ^\n                     keySchedule[ksRow++];\n            const t2 = sub_mix_0[s2 >>> 24] ^ sub_mix_1[(s3 >>> 16) & 0xff] ^ sub_mix_2[(s0 >>> 8) & 0xff] ^ sub_mix_3[s1 & 0xff] ^\n                     keySchedule[ksRow++];\n            const t3 = sub_mix_0[s3 >>> 24] ^ sub_mix_1[(s0 >>> 16) & 0xff] ^ sub_mix_2[(s1 >>> 8) & 0xff] ^ sub_mix_3[s2 & 0xff] ^\n                     keySchedule[ksRow++];\n\n            // Update state\n            s0 = t0;\n            s1 = t1;\n            s2 = t2;\n            s3 = t3;\n        }\n\n        // Shift rows, sub bytes, add round key\n        const t0g = ((sbox[s0 >>> 24] << 24) | (sbox[(s1 >>> 16) & 0xff] << 16) | (sbox[(s2 >>> 8) & 0xff] << 8) | sbox[s3 & 0xff]) ^\n                    keySchedule[ksRow++];\n        const t1g = ((sbox[s1 >>> 24] << 24) | (sbox[(s2 >>> 16) & 0xff] << 16) | (sbox[(s3 >>> 8) & 0xff] << 8) | sbox[s0 & 0xff]) ^\n                    keySchedule[ksRow++];\n        const t2g = ((sbox[s2 >>> 24] << 24) | (sbox[(s3 >>> 16) & 0xff] << 16) | (sbox[(s0 >>> 8) & 0xff] << 8) | sbox[s1 & 0xff]) ^\n                    keySchedule[ksRow++];\n        const t3g = ((sbox[s3 >>> 24] << 24) | (sbox[(s0 >>> 16) & 0xff] << 16) | (sbox[(s1 >>> 8) & 0xff] << 8) | sbox[s2 & 0xff]) ^\n                    keySchedule[ksRow++];\n\n        // Set output\n        M[offset]     = t0g;\n        M[offset + 1] = t1g;\n        M[offset + 2] = t2g;\n        M[offset + 3] = t3g;\n    }\n}","import { Hasher } from '../lib/Hasher';\nimport { WordArray } from '../lib/WordArray';\n\n// Initialization and round constants tables\nconst H: Array<number> = [];\nconst K: Array<number> = [];\n\n// Reusable object\nconst W: Array<number> = [];\n\nexport class SHA256 extends Hasher {\n    public _hash!: WordArray;\n\n    public reset() {\n        // reset core values\n        super.reset();\n\n        this._hash = new WordArray(H.slice(0));\n    }\n\n    public _doProcessBlock(M: Array<number>, offset: number) {\n        // Shortcut\n        const Hl = this._hash.words;\n\n        // Working variables\n        let a = Hl[0];\n        let b = Hl[1];\n        let c = Hl[2];\n        let d = Hl[3];\n        let e = Hl[4];\n        let f = Hl[5];\n        let g = Hl[6];\n        let h = Hl[7];\n\n        // Computation\n        for(let i = 0; i < 64; i++) {\n            if(i < 16) {\n                W[i] = M[offset + i] | 0;\n            } else {\n                const gamma0x = W[i - 15];\n                const gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                              ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                               (gamma0x >>> 3);\n\n                const gamma1x = W[i - 2];\n                const gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                              ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                               (gamma1x >>> 10);\n\n                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n            }\n\n            const ch  = (e & f) ^ (~e & g);\n            const maj = (a & b) ^ (a & c) ^ (b & c);\n\n            const sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n            const sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n            const t1 = h + sigma1 + ch + K[i] + W[i];\n            const t2 = sigma0 + maj;\n\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n\n        // Intermediate hash value\n        Hl[0] = (Hl[0] + a) | 0;\n        Hl[1] = (Hl[1] + b) | 0;\n        Hl[2] = (Hl[2] + c) | 0;\n        Hl[3] = (Hl[3] + d) | 0;\n        Hl[4] = (Hl[4] + e) | 0;\n        Hl[5] = (Hl[5] + f) | 0;\n        Hl[6] = (Hl[6] + g) | 0;\n        Hl[7] = (Hl[7] + h) | 0;\n    }\n\n    public _doFinalize(): WordArray {\n        const nBitsTotal = this._nDataBytes * 8;\n        const nBitsLeft = this._data.sigBytes * 8;\n\n        // Add padding\n        this._data.words[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n        this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n        this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n        this._data.sigBytes = this._data.words.length * 4;\n\n        // Hash final blocks\n        this._process();\n\n        // Return final computed hash\n        return this._hash;\n    }\n}","import { WordArray } from '../lib/WordArray';\nimport { Padding } from '../pad/Padding';\n\nexport class NoPadding {\n    /**\n     * Doesn't pad the data provided.\n     *\n     * @param data The data to pad.\n     * @param blockSize The multiple that the data should be padded to.\n     *\n     * @example\n     *\n     *     NoPadding.pad(wordArray, 4);\n     */\n    public static pad(data: WordArray, blockSize: number): void {\n    }\n\n    /**\n     * Doesn't unpad the data provided.\n     *\n     * @param data The data to unpad.\n     *\n     * @example\n     *\n     *     NoPadding.unpad(wordArray);\n     */\n    public static unpad(data: WordArray): void {\n    }\n}\n\n// type guard for the padding (to ensure it has the required static methods)\nconst _: Padding = NoPadding;","import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class ECBEncryptor extends BlockCipherModeAlgorithm {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        this._cipher.encryptBlock(words, offset);\n    }\n}","import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class ECBDecryptor extends BlockCipherModeAlgorithm {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        this._cipher.decryptBlock(words, offset);\n    }\n}","import { BlockCipherMode } from './BlockCipherMode';\nimport { ECBEncryptor } from './ECBEncryptor';\nimport { ECBDecryptor } from './ECBDecryptor';\n\n/**\n * Cipher Block Chaining mode.\n */\nexport abstract class ECB extends BlockCipherMode {\n    public static Encryptor: typeof ECBEncryptor = ECBEncryptor;\n\n    public static Decryptor: typeof ECBDecryptor = ECBDecryptor;\n}","// DEPENDENCIES ////////////////////////////////////////////////////////////////////////////////////\n\n// import indirectly referenced declarations\nimport { BufferedBlockAlgorithmConfig } from './lib/BufferedBlockAlgorithmConfig';\n\n// LIB /////////////////////////////////////////////////////////////////////////////////////////////\n\nimport { WordArray } from './lib/WordArray';\nimport { BlockCipher } from './lib/BlockCipher';\nimport { CipherParams } from './lib/CipherParams';\nimport { Hasher } from './lib/Hasher';\nimport { SerializableCipher } from './lib/SerializableCipher';\nimport { PasswordBasedCipher } from './lib/PasswordBasedCipher';\n\nexport const lib = {\n    BlockCipher: BlockCipher,\n    WordArray: WordArray,\n    CipherParams: CipherParams,\n    Hasher: Hasher,\n    SerializableCipher: SerializableCipher,\n    PasswordBasedCipher: PasswordBasedCipher\n};\n\n// ALGORITHMS //////////////////////////////////////////////////////////////////////////////////////\n\nimport { AES as AESAlgorithm } from './algo/AES';\nimport { SHA256 as SHA256Algorithm } from './algo/SHA256';\n\nexport const algo = {\n    AES: AESAlgorithm,\n    SHA256: SHA256Algorithm\n};\n\n// ENCODINGS ///////////////////////////////////////////////////////////////////////////////////////\n\nimport { Utf8 } from './enc/Utf8';\nimport { Hex } from './enc/Hex';\n\nexport const enc = {\n    Utf8: Utf8,\n    Hex: Hex\n};\n\n// PADDING /////////////////////////////////////////////////////////////////////////////////////////\n\nimport { NoPadding } from './pad/NoPadding';\nimport { PKCS7 } from './pad/PKCS7';\n\nexport const pad = {\n    NoPadding: NoPadding,\n    PKCS7: PKCS7\n};\n\n// MODES ///////////////////////////////////////////////////////////////////////////////////////////\n\nimport { CBC } from './mode/CBC';\nimport { ECB } from './mode/ECB';\n\nexport const mode = {\n    CBC: CBC,\n    ECB: ECB\n};\n\n// HELPERS /////////////////////////////////////////////////////////////////////////////////////////\n\nexport const AES = lib.BlockCipher._createHelper(algo.AES);\nexport const SHA256 = lib.Hasher._createHelper(algo.SHA256);"],"names":["AESAlgorithm","SHA256Algorithm","AES","SHA256"],"mappings":"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AAC,CAAC;QAC9C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/C,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAA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"}