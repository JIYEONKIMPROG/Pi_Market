'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lib = require('@web-std/blob');
var test$1 = require('./test.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var lib__namespace = /*#__PURE__*/_interopNamespace(lib);

/**
 * @param {import('./test').Test} test
 */
const test = test => {
  test("test baisc", async () => {
    test$1.assert.isEqual(typeof lib__namespace.Blob, "function");
    test$1.assert.isEqual(typeof lib__namespace.TextDecoder, "function");
    test$1.assert.isEqual(typeof lib__namespace.TextEncoder, "function");
    test$1.assert.isEqual(typeof lib__namespace.ReadableStream, "function");
  });

  if (globalThis.window === globalThis) {
    test("exports built-ins", () => {
      test$1.assert.equal(lib__namespace.Blob, globalThis.Blob);
      test$1.assert.equal(lib__namespace.TextDecoder, globalThis.TextDecoder);
      test$1.assert.equal(lib__namespace.TextEncoder, globalThis.TextEncoder);
      test$1.assert.equal(lib__namespace.ReadableStream, globalThis.ReadableStream);
    });
  }

  test("test jsdom", async () => {
    const blob = new lib.Blob(["TEST"]);
    test$1.assert.isEqual(blob.size, 4, "Initial blob should have a size of 4");
  });

  test("should encode a blob with proper size when given two strings as arguments", async () => {
    const blob = new lib.Blob(["hi", "hello"]);
    test$1.assert.isEqual(blob.size, 7);
  });

  test("should encode arraybuffers with right content", async () => {
    const bytes = new Uint8Array(5);
    for (let i = 0; i < 5; i++) bytes[i] = i;
    const blob = new lib.Blob([bytes.buffer]);
    const buffer = await blob.arrayBuffer();
    const result = new Uint8Array(buffer);
    for (let i = 0; i < 5; i++) {
      test$1.assert.isEqual(result[i], i);
    }
  });

  test("should encode typed arrays with right content", async () => {
    const bytes = new Uint8Array(5);
    for (let i = 0; i < 5; i++) bytes[i] = i;
    const blob = new lib.Blob([bytes]);

    const buffer = await blob.arrayBuffer();
    const result = new Uint8Array(buffer);

    for (let i = 0; i < 5; i++) {
      test$1.assert.isEqual(result[i], i);
    }
  });

  test("should encode sliced typed arrays with right content", async () => {
    const bytes = new Uint8Array(5);
    for (let i = 0; i < 5; i++) bytes[i] = i;
    const blob = new lib.Blob([bytes.subarray(2)]);

    const buffer = await blob.arrayBuffer();
    const result = new Uint8Array(buffer);
    for (let i = 0; i < 3; i++) {
      test$1.assert.isEqual(result[i], i + 2);
    }
  });

  test("should encode with blobs", async () => {
    const bytes = new Uint8Array(5);
    for (let i = 0; i < 5; i++) bytes[i] = i;
    const blob = new lib.Blob([new lib.Blob([bytes.buffer])]);
    const buffer = await blob.arrayBuffer();
    const result = new Uint8Array(buffer);
    for (let i = 0; i < 5; i++) {
      test$1.assert.isEqual(result[i], i);
    }
  });

  test("should enode mixed contents to right size", async () => {
    const bytes = new Uint8Array(5);
    for (let i = 0; i < 5; i++) {
      bytes[i] = i;
    }
    const blob = new lib.Blob([bytes.buffer, "hello"]);
    test$1.assert.isEqual(blob.size, 10);
  });

  test("should accept mime type", async () => {
    const blob = new lib.Blob(["hi", "hello"], { type: "text/html" });
    test$1.assert.isEqual(blob.type, "text/html");
  });

  test("should be an instance of constructor", async () => {
    const blob = new lib.Blob(["hi"]);
    test$1.assert.ok(blob instanceof lib.Blob);
  });

  test("from text", async () => {
    const blob = new lib.Blob(["hello"]);
    test$1.assert.isEqual(blob.size, 5, "is right size");
    test$1.assert.isEqual(blob.type, "", "type is empty");
    test$1.assert.isEqual(await blob.text(), "hello", "reads as text");
    test$1.assert.isEquivalent(
      new Uint8Array(await blob.arrayBuffer()),
      new Uint8Array("hello".split("").map(char => char.charCodeAt(0)))
    );
  });

  test("from text with type", async () => {
    const blob = new lib.Blob(["hello"], { type: "text/markdown" });
    test$1.assert.isEqual(blob.size, 5, "is right size");
    test$1.assert.isEqual(blob.type, "text/markdown", "type is set");
    test$1.assert.isEqual(await blob.text(), "hello", "reads as text");

    test$1.assert.isEquivalent(
      new Uint8Array(await blob.arrayBuffer()),
      new Uint8Array("hello".split("").map(char => char.charCodeAt(0)))
    );
  });

  test("empty blob", async () => {
    const blob = new lib.Blob([]);
    test$1.assert.isEqual(blob.size, 0, "size is 0");
    test$1.assert.isEqual(blob.type, "", "type is empty");
    test$1.assert.isEqual(await blob.text(), "", "reads as text");
    test$1.assert.isEquivalent(
      await blob.arrayBuffer(),
      new ArrayBuffer(0),
      "returns empty buffer"
    );
  });

  test("no args", async () => {
    const blob = new lib.Blob();
    test$1.assert.isEqual(blob.size, 0, "size is 0");
    test$1.assert.isEqual(blob.type, "", "type is empty");
    test$1.assert.isEqual(await blob.text(), "", "reads as text");
    test$1.assert.isEquivalent(
      await blob.arrayBuffer(),
      new ArrayBuffer(0),
      "returns empty buffer"
    );
  });

  test("all emtpy args", async () => {
    const blob = new lib.Blob([
      "",
      new lib.Blob(),
      "",
      new Uint8Array(0),
      new ArrayBuffer(0),
    ]);
    test$1.assert.isEqual(blob.size, 0, "size is 0");
    test$1.assert.isEqual(blob.type, "", "type is empty");
    test$1.assert.isEqual(await blob.text(), "", "reads as text");
    test$1.assert.isEquivalent(
      await blob.arrayBuffer(),
      new ArrayBuffer(0),
      "returns empty buffer"
    );
  });

  test("combined blob", async () => {
    const uint8 = new Uint8Array([1, 2, 3]);
    const uint16 = new Uint16Array([8, 190]);
    const float32 = new Float32Array([5.4, 9, 1.5]);
    const string = "hello world";
    const blob = new lib.Blob([uint8, uint16, float32, string]);

    const b8 = blob.slice(0, uint8.byteLength);
    const r8 = new Uint8Array(await b8.arrayBuffer());
    test$1.assert.isEquivalent(uint8, r8);

    const b16 = blob.slice(
      uint8.byteLength,
      uint8.byteLength + uint16.byteLength
    );
    const r16 = new Uint16Array(await b16.arrayBuffer());
    test$1.assert.isEquivalent(uint16, r16);

    const b32 = blob.slice(
      uint8.byteLength + uint16.byteLength,
      uint8.byteLength + uint16.byteLength + float32.byteLength
    );
    const r32 = new Float32Array(await b32.arrayBuffer());
    test$1.assert.isEquivalent(float32, r32);

    const bs = blob.slice(
      uint8.byteLength + uint16.byteLength + float32.byteLength
    );
    test$1.assert.isEqual(string, await bs.text());

    test$1.assert.isEqual("wo", await bs.slice(6, 8).text());
    test$1.assert.isEqual("world", await bs.slice(6).text());
    test$1.assert.isEqual("world", await blob.slice(-5).text());
  });

  test("emoji", async () => {
    const emojis = `ðŸ‘ðŸ¤·ðŸŽ‰ðŸ˜¤`;
    const blob = new lib.Blob([emojis]);
    const nestle = new lib.Blob([new lib.Blob([blob, blob])]);
    test$1.assert.isEqual(emojis + emojis, await nestle.text());
  });

  test("streams", async () => {
    const blob = new lib.Blob(["hello", " ", "world"], { type: "text/plain" });
    const stream = blob.stream();

    const reader = stream.getReader();
    const chunks = [];
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break
      }

      if (value != null) {
        chunks.push(new lib.TextDecoder().decode(value));
      }
    }

    test$1.assert.deepEqual("hello world", chunks.join(""));
  });
};

exports.test = test;
//# sourceMappingURL=blob.spec.cjs.map
