'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lib = require('@web-std/form-data');
var file = require('@web-std/file');
var test$1 = require('./test.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var lib__namespace = /*#__PURE__*/_interopNamespace(lib);

/**
 * @param {import('./test').Test} test
 */
const test = test => {
  test("slow down", async () => {
    await new Promise(resolve => setTimeout(resolve));
    test$1.assert.ok(true, "run now");
  });

  test("test baisc", async () => {
    test$1.assert.equal(typeof lib.FormData, "function");
    test$1.assert.isEqual(typeof lib__namespace.FormData, "function");
  });

  if (globalThis.window === globalThis) {
    test("exports built-ins", () => {
      test$1.assert.equal(lib__namespace.FormData, globalThis.FormData);
    });
  }

  // @see https://github.com/jsdom/jsdom/blob/5279cfda5fe4d52f04b2eb6a801c98d81f9b55da/test/web-platform-tests/to-upstream/XMLHttpRequest/formdata-set-blob.HTMLFormElement
  test("blob without type", () => {
    const formData = new lib.FormData();
    formData.set("blob-1", new file.Blob());
    const blob1 = /** @type {File} */ (formData.get("blob-1"));
    test$1.assert.equal(blob1.constructor.name, "File");
    test$1.assert.equal(blob1.name, "blob");
    test$1.assert.equal(blob1.type, "");
    test$1.assert.isLessThan(
      Math.abs(blob1.lastModified - Date.now()),
      200,
      "lastModified should be now"
    );
  });

  test("blob with type", () => {
    const formData = new lib.FormData();
    formData.set("blob-2", new file.Blob([], { type: "text/plain" }));
    const blob2 = /** @type {File} */ (formData.get("blob-2"));
    test$1.assert.equal(blob2.constructor.name, "File");
    test$1.assert.equal(blob2.name, "blob");
    test$1.assert.equal(blob2.type, "text/plain");
    test$1.assert.isLessThan(
      Math.abs(blob2.lastModified - Date.now()),
      200,
      "lastModified should be now"
    );
  });

  test("blob with custom name", () => {
    const formData = new lib.FormData();
    formData.set("blob-3", new file.Blob(), "custom name");
    const blob3 = /** @type {File} */ (formData.get("blob-3"));
    test$1.assert.equal(blob3.constructor.name, "File");
    test$1.assert.equal(blob3.name, "custom name");
    test$1.assert.equal(blob3.type, "");
    test$1.assert.isLessThan(
      Math.abs(blob3.lastModified - Date.now()),
      200,
      "lastModified should be now"
    );
  });

  test("file without lastModified or custom name", () => {
    const formData = new lib.FormData();
    formData.set("file-1", new file.File([], "name"));
    const file1 = /** @type {File} */ (formData.get("file-1"));
    test$1.assert.equal(file1.constructor.name, "File");
    test$1.assert.equal(file1.name, "name");
    test$1.assert.equal(file1.type, "");
    test$1.assert.isLessThan(
      Math.abs(file1.lastModified - Date.now()),
      200,
      "lastModified should be now"
    );
  });

  test("file with lastModified and custom name", () => {
    const formData = new lib.FormData();
    formData.set(
      "file-2",
      new file.File([], "name", { lastModified: 123 }),
      "custom name"
    );
    const file2 = /** @type {File} */ (formData.get("file-2"));
    test$1.assert.equal(file2.constructor.name, "File");
    test$1.assert.equal(file2.name, "custom name");
    test$1.assert.equal(file2.type, "");
    test$1.assert.equal(file2.lastModified, 123, "lastModified should be 123");
  });

  test("throws on few args", () => {
    const data = new lib.FormData();
    // @ts-expect-error
    test$1.assert.throws(() => data.append("key"));
    // @ts-expect-error
    test$1.assert.throws(() => data.set("key"));
    // @ts-expect-error
    test$1.assert.throws(() => data.get());
    // @ts-expect-error
    test$1.assert.throws(() => data.getAll());
    // @ts-expect-error
    test$1.assert.throws(() => data.delete());
  });

  test("only value", () => {
    const data = new lib.FormData();
    data.set("key", "value1");
    test$1.assert.equal(data.get("key"), "value1");
  });

  test("second value", () => {
    const data = new lib.FormData();
    data.set("key", "value1");
    data.append("key", "value2");
    test$1.assert.equal(data.get("key"), "value1");
  });

  test("null value", () => {
    const data = new lib.FormData();
    // @ts-expect-error
    data.set("key", null);
    test$1.assert.equal(data.get("key"), "null");
  });

  test("has", () => {
    var data = new lib.FormData();
    data.append("n1", "value");
    test$1.assert.equal(data.has("n1"), true);
    test$1.assert.equal(data.has("n2"), false);
    data.append("n2", "value");
    test$1.assert.equal(data.has("n1"), true);
    test$1.assert.equal(data.has("n2"), true);
    data.append("n3", new file.Blob(["content"]));
    test$1.assert.equal(data.has("n3"), true);
  });

  test("should return the keys/values/entres as they are appended", () => {
    const data = new lib.FormData();
    data.append("keyA", "val1");
    data.append("keyA", "val2");
    data.append("keyB", "val3");
    data.append("keyA", "val4");

    test$1.assert.deepEqual([...data.keys()], ["keyA", "keyA", "keyB", "keyA"]);
    test$1.assert.deepEqual([...data.values()], ["val1", "val2", "val3", "val4"]);
    test$1.assert.deepEqual(
      [...data],
      [
        ["keyA", "val1"],
        ["keyA", "val2"],
        ["keyB", "val3"],
        ["keyA", "val4"],
      ]
    );
  });

  test("overwrite first matching key", () => {
    const data = new lib.FormData();
    data.append("keyA", "val1");
    data.append("keyA", "val2");
    data.append("keyB", "val3");
    data.append("keyA", "val4");

    data.set("keyA", "val3");
    test$1.assert.deepEqual(
      [...data],
      [
        ["keyA", "val3"],
        ["keyB", "val3"],
      ]
    );
  });

  test("appends value when no matching", () => {
    const data = new lib.FormData();
    data.append("keyB", "val3");
    data.set("keyA", "val3");

    test$1.assert.deepEqual(
      [...data],
      [
        ["keyB", "val3"],
        ["keyA", "val3"],
      ]
    );
  });

  test("FormData.delete()", () => {
    var data = new lib.FormData();
    data.append("name", "value");
    test$1.assert.equal(data.has("name"), true);
    data.delete("name");
    test$1.assert.equal(data.has("name"), false);

    data.append("name", new file.Blob(["content"]));
    test$1.assert.equal(data.has("name"), true);
    data.delete("name");
    test$1.assert.equal(data.has("name"), false);

    data.append("n1", "v1");
    data.append("n2", "v2");
    data.append("n1", "v3");
    data.delete("n1");
    test$1.assert.equal(data.has("n1"), false);

    test$1.assert.deepEqual([...data], [["n2", "v2"]]);
  });

  test("Shold return correct filename with File", () => {
    const data = new lib.FormData();
    data.set("key", new file.File([], "doc.txt"));
    const file$1 = /** @type {File} */ (data.get("key"));
    test$1.assert.equal("doc.txt", file$1.name);
  });

  test("Shold return correct filename with Blob filename", () => {
    const data = new lib.FormData();
    data.append("key", new file.Blob(), "doc.txt");
    const file$1 = /** @type {File} */ (data.get("key"));
    test$1.assert.equal("doc.txt", file$1.name);
  });

  test("Shold return correct filename with just Blob", () => {
    const data = new lib.FormData();
    data.append("key", new file.Blob());
    const file$1 = /** @type {File} */ (data.get("key"));
    test$1.assert.equal("blob", file$1.name);
  });

  test.skip("complicated form", () => {
    const data = new lib.FormData();
    data.append("blobs", new file.Blob(["basic"]));
    data.append("blobs", new file.Blob(["with-type"], { type: "text/plain" }));
    data.append(
      "blobs",
      new file.Blob(["with-name"], { type: "text/markdown" }),
      "file.md"
    );
    data.append("files", new file.File(["basic"], "basic"));
    data.append(
      "files",
      new file.File(["with-type"], "file.txt", { type: "text/plain" })
    );
    data.append(
      "files",
      new file.File(["renamed"], "orig.txt", { type: "text/plain" }),
      "rename.md"
    );
  });
};

exports.test = test;
//# sourceMappingURL=form-data.spec.cjs.map
